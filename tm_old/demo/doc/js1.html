<!DOCTYPE html>
<html><head><meta charset="UTF-8">
<link href="/favicon.ico" rel="shortcut icon" type="image/x-icon">
<style>@import url('main.css');</style>
<title></title>indexedDB</head>

<body>

<article itemprop="articleBody">
　　indexedDB的出现是Web前端数据存储发展的一个伟大进步，Chrome和Firefox都可以兼容，IE从10才开始兼容。比起WebSQL，indexedDB的使用要繁琐一些，不过它的功能也要强大一些。indexedDB的操作基本上是异步的，需要通过回调函数来操作对象。<br>
　　indexedDB的工作流程有点复杂，打开一个数据库的步骤大概是这样的：<br>
<style>
article li {list-style:inside decimal;margin-left:20px;}
</style>
<code><ol>
<li>调用open方法，返回一个数据库连接对象</li>
<li>如果数据库不存在或数据库请求升级<ol><li>触发数据库连接对象上的数据初始化事件</li></ol></li>
<li>如果数据库成功打开或创建成功<ol><li>触发数据库连接对象上的成功事件</li></ol></li>
<li>否则<ol><li>触发数据库连接对象上的失败事件</li></ol></li>
</ol></code>
　　由于初始化事件未必会被调用，所以我们通常在成功事件中获取数据库对象。
<code><font color="#998877">//调整webkit兼容性</font><br><font color="#5555AA">window</font>.indexedDB=<font color="#5555AA">window</font>.indexedDB||<font color="#5555AA">window</font>.webkitIndexedDB;<br><br><font color="#333388">var</font>&nbsp;cn,db;<br><br><font color="#998877">//打开数据库</font><br><font color="#998877">//第一个参数是数据库名（打开即创建，没有其它独立的创建方法）</font><br><font color="#998877">//其它参数以后解释</font><br><font color="#333388">var</font>&nbsp;cn=indexedDB.open(<font color="#AA5544">"MyDB"</font>);<br><br><font color="#998877">//数据库初始化事件</font><br>cn.onupgradeneeded=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;<font color="#998877">//获取数据库对象</font><br>&nbsp;&nbsp;db=e.target.result;<br>&nbsp;&nbsp;<font color="#998877">//创建数据库实例</font><br>&nbsp;&nbsp;<font color="#998877">//第一个是存储对象名，类似关系数据库的表名</font><br>&nbsp;&nbsp;<font color="#998877">//第二个参数是主键名，还有其他选项，可以设置自增的</font><br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;o=db.createObjectStore(<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#AA5544">"MyOBJ"</font>,{keyPath:<font color="#AA5544">"title"</font>}<br>&nbsp;&nbsp;);<br>};<br><br><font color="#998877">//数据库打开成功事件</font><br>cn.onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;<font color="#998877">//获取数据库对象</font><br>&nbsp;&nbsp;<font color="#998877">//因为上面的初始化事件未必会被调用到，这里当然也得获取一次</font><br>&nbsp;&nbsp;db=e.target.result;<br>&nbsp;&nbsp;<font color="#998877">//这个是我自定义的方法，为了方便操作而已</font><br>&nbsp;&nbsp;<font color="#998877">//因为indexedDB的事务机制也是异步的</font><br>&nbsp;&nbsp;<font color="#998877">//如果不定义一个方法来简化这个事物操作每次都要去创建事物，获取储存对象很麻烦</font><br>&nbsp;&nbsp;<font color="#998877">//这个doTransaction的参数是一个回调函数，可以把这个回调函数当作事物的过程使用</font><br>&nbsp;&nbsp;db.doTransaction=<font color="#333388">function</font>(f){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//db的transation方法是开始一个事务</font><br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//第一个参数是要操作的数据库（多个时可以用数组），表示这个事务中使用的存储对象</font><br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//第二个参数是访问模式，目前的版本支持readwrite和readonly两种操作</font><br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//从事务对象闪使用objectStore访问具体的存储对象，并把结果传给回调函数</font><br>&nbsp;&nbsp;&nbsp;&nbsp;f(db.transaction(<font color="#AA5544">"MyOBJ"</font>,<font color="#AA5544">"readwrite"</font>).objectStore(<font color="#AA5544">"MyOBJ"</font>));<br>&nbsp;&nbsp;};<br>};</code>
　　这些就是indexedDB的打开与创建。其实代码不多，只是注释多，好好看很容易明白。打开了数据库之后，我们在成功事件中已经把数据库对象放入全局变量里了吧。接着，我们要用这个打开的数据库对象来写入和读取数据。这些放到交互中操作，首先放置两个按钮，一个是写入一个是读取。
<code><font color="#800080">&lt;input</font><font color="#994300">&nbsp;type</font><font color="#800080">="</font><font color="#1A1AA6">button</font><font color="#800080">"</font><font color="#994300">&nbsp;value</font><font color="#800080">="</font><font color="#1A1AA6">读取数据</font><font color="#800080">"</font><font color="#994300">&nbsp;id</font><font color="#800080">="</font><font color="#1A1AA6">readButton</font><font color="#800080">"</font><font color="#800080">/&gt;</font><br><font color="#800080">&lt;input</font><font color="#994300">&nbsp;type</font><font color="#800080">="</font><font color="#1A1AA6">button</font><font color="#800080">"</font><font color="#994300">&nbsp;value</font><font color="#800080">="</font><font color="#1A1AA6">添加数据</font><font color="#800080">"</font><font color="#994300">&nbsp;id</font><font color="#800080">="</font><font color="#1A1AA6">writeButton</font><font color="#800080">"</font><font color="#800080">/&gt;</font><br><font color="#800080">&lt;script</font><font color="#800080">&gt;</font><br><font color="#998877">//这里放入上面打开数据库的代码</font><br><font color="#998877">//因为后面的代码中要用到打开的数据库</font><br><br>readButton.onclick=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;<font color="#998877">//调用我们自己添加的方法来处理一个事务</font><br>&nbsp;&nbsp;db.doTransaction(<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//openCursor是把游标移动到初始位置</font><br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//这个方法参数比较复杂，以后再说</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.openCursor().onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//获取当前游标对象所在行</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;r=e.target.result;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//如果行不村咋，就退出，其实就是EOF的情况</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">if</font>(!r)<font color="#333388">return</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//输出行数据到控制台</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#5555AA">console.log</font>(r.value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//游标下移，这个方法也会触发成功事件</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//所以变成递归遍历数据了</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.<font color="#333388">continue</font>();<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;});<br>};<br>writeButton.onclick=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;<font color="#998877">//调用我们自己添加的方法来处理一个事务</font><br>&nbsp;&nbsp;db.doTransaction(<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//清除原有的数据</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.clear();<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//循环写入100条数据</font><br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//这个e是存储对象，除了add，还有好多方法，这个我们也以后再说</font><br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">for</font>(<font color="#333388">var</font>&nbsp;i=<font color="#CC3322">0</font>;i&lt;<font color="#CC3322">100</font>;i++)e.add({title:i});<br>&nbsp;&nbsp;});<br>};<br><font color="#800080">&lt;/script&gt;</font></code>
<img src="pictures/a5ff579bf6eec5fcf0d9eb962c15759c.png" headerloaded="true"><br>
　　这篇文章就是说这个基本的数据库连接和读写，只要好好看这个例子就一定可以明白的（注释比代码还多了）。其实只要记住一个核心思想：<strong>异步</strong>。几乎所有操作都是异步的，即使是仅读取一条记录也必须异步。<br>
<br>
参考：<br>
　　<a href="https://developer.mozilla.org/en-US/docs/IndexedDB/Using_IndexedDB" target="_blank" rel="nofollow">https://developer.mozilla.org/en-US/docs/IndexedDB/Using_IndexedDB</a><br>
　　<a href="http://msdn.microsoft.com/en-us/library/windows/apps/hh466139.aspx" target="_blank" rel="nofollow">http://msdn.microsoft.com/en-us/library/windows/apps/hh466139.aspx</a><br>
      </article>

<article itemprop="articleBody">
　　indexedDB也是使用看似二维表来存储数据的，但实际上是线性的对象序列，这些序列被称为存储对象。这些存储对象还可以设置上相应的索引来做更为复杂的操作，但并不是任何时候都可以修改存储对象的结构。通常一次性设置完毕，以后就很少改动了。<br>
　　实际上indexedDB的数据对象只是普通的key-value结构，这样看来只是个列表。但是这个value可以是JavaScript的Object，也就是说又是key-value结构。这两个key-value结构叠加起来就成了一个二维表。实际上最为数据的JavaScript对象还可以是树形的，所以它甚至可以作为一个高维表来使用。indexedDB还可以为Object的键值加上一些索引和约束来实现更复杂的功能。<br>
　　下面这个代码片段是创建三个不同配置的存储对象
<code>cn.onupgradeneeded=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;db=e.target.result;<br>&nbsp;&nbsp;<font color="#998877">//TAB1只有id主键</font><br>&nbsp;&nbsp;db.createObjectStore(<font color="#AA5544">"TAB1"</font>,{keyPath:<font color="#AA5544">"id"</font>});<br>&nbsp;&nbsp;<font color="#998877">//TAB2主键不设名字，只是自增而已</font><br>&nbsp;&nbsp;db.createObjectStore(<font color="#AA5544">"TAB2"</font>,{autoIncrement:<font color="#DD6600">true</font>});<br>&nbsp;&nbsp;<font color="#998877">//TAB3主键有名字，且自增</font><br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;o=db.createObjectStore(<font color="#AA5544">"TAB3"</font>,{keyPath:<font color="#AA5544">"id"</font>,autoIncrement:<font color="#DD6600">true</font>});<br>&nbsp;&nbsp;<font color="#998877">//给TAB3添加title索引，</font><br>&nbsp;&nbsp;<font color="#998877">//第一个参数是索引名</font><br>&nbsp;&nbsp;<font color="#998877">//第二个参数是索引的字段名（多个时可以使用数组）</font><br>&nbsp;&nbsp;<font color="#998877">//第三个参数是的配置信息，目前版本有unique和multiEntry可用</font><br>&nbsp;&nbsp;o.createIndex(<font color="#AA5544">"title"</font>,<font color="#AA5544">"title"</font>,{unique:<font color="#DD6600">true</font>});<br>};</code>
　　这些初始化操作必须在upgradeneeded事件中完成，它只会在创建数据库或数据库版本提升时触发，所以一旦创建就要尽量减少更改。创建了存储对象后我们就可以写入数据了。
<code>&lt;input&nbsp;type=<font color="#AA5544">"button"</font>&nbsp;value=<font color="#AA5544">"写入数据"</font>&nbsp;id=<font color="#AA5544">"writeButton"</font>&nbsp;/&gt;<br>&lt;script&gt;<br><font color="#5555AA">window</font>.indexedDB=<font color="#5555AA">window</font>.indexedDB||<font color="#5555AA">window</font>.webkitIndexedDB;<br><br><font color="#333388">var</font>&nbsp;cn,db;<br><br><font color="#333388">var</font>&nbsp;cn=indexedDB.open(<font color="#AA5544">"MyDB"</font>,<font color="#CC3322">1</font>);<br><br><font color="#998877">//这里放上面的初始化事件</font><br><br>cn.onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;db=e.target.result;<br>&nbsp;&nbsp;<font color="#998877">//由于这次是操作多个存储对象，所以就不自定义个方法来操作了</font><br>};<br><br>writeButton.onclick=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;s,t1,t2,t3,i;<br>&nbsp;&nbsp;<font color="#998877">//创建事务对象</font><br>&nbsp;&nbsp;s=db.transaction([<font color="#AA5544">"TAB1"</font>,<font color="#AA5544">"TAB2"</font>,<font color="#AA5544">"TAB3"</font>],<font color="#AA5544">"readwrite"</font>);<br>&nbsp;&nbsp;<font color="#998877">//获取存储对象</font><br>&nbsp;&nbsp;t1=s.objectStore(<font color="#AA5544">"TAB1"</font>);<br>&nbsp;&nbsp;t2=s.objectStore(<font color="#AA5544">"TAB2"</font>);<br>&nbsp;&nbsp;t3=s.objectStore(<font color="#AA5544">"TAB3"</font>);<br>&nbsp;&nbsp;<font color="#998877">//清空数据</font><br>&nbsp;&nbsp;t1.clear();t2.clear();t3.clear();<br>&nbsp;&nbsp;<font color="#998877">//循环写入数据</font><br>&nbsp;&nbsp;<font color="#333388">for</font>(i=<font color="#CC3322">0</font>;i&lt;<font color="#CC3322">100</font>;i++){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//TAB1只有id字段</font><br>&nbsp;&nbsp;&nbsp;&nbsp;t1.add({id:i});<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//TAB2虽有id字段，但是自增的，不需要赋值</font><br>&nbsp;&nbsp;&nbsp;&nbsp;t2.add({});<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//TAB3的id字段自增的，不需要赋值。但是title需要</font><br>&nbsp;&nbsp;&nbsp;&nbsp;t3.add({title:i});<br>&nbsp;&nbsp;};<br>};<br>&lt;/script&gt;</code>
<img src="pictures/c4b57a56c14808d541c86c9c1ac8bab6.png" headerloaded="true" width="596" style="cursor: pointer;"><br>
　　写入数据不能和修改数据库结构在同一个事务中，应该在onsuccess事件触发之后再创建事务来写入数据。indexedDB没有传统关系数据库那么复杂的数据结构和关系，只是做简单的key-value存储而已。写入数据就和对数组push一个object那么简单。<br>
　　自增字段可以不用指定值，自增的字段是从1开始的，我们循环赋值的title是从0开始的所以得到这样一个表。当然我们可以添加更多的字段来做更复杂的表，上面的代码只是个例子而已。还要注意一点，当我们调用clear来清空存储对象的数据时，自增字段的开始位置数据不会被清空，除非删除整个存储对象。<br>
<br>
参考：<br>
　　<a href="https://developer.mozilla.org/en-US/docs/IndexedDB/Using_IndexedDB" target="_blank" rel="nofollow">https://developer.mozilla.org/en-US/docs/IndexedDB/Using_IndexedDB</a><br>
　　<a href="http://msdn.microsoft.com/en-us/library/windows/apps/hh466139.aspx" target="_blank" rel="nofollow">http://msdn.microsoft.com/en-us/library/windows/apps/hh466139.aspx</a><br>
      </article>
<article itemprop="articleBody">
　　事务机制也算不上什么稀奇的东西，WebSQL也通过事务机制操作的。但是indexedDB的事务机制很特别，它不是通过回调函数处理的，而是按照当前执行的同步代码来作为事务的作用域。这东西稍微有点创新，不过看下例子也很容易理解的。<br>
　　我们先来一段最简单的测试代码，看括之前的两篇，这个代码不需要注释也能理解
<code><font color="#800080">&lt;input</font><font color="#994300">&nbsp;type</font><font color="#800080">="</font><font color="#1A1AA6">button</font><font color="#800080">"</font><font color="#994300">&nbsp;value</font><font color="#800080">="</font><font color="#1A1AA6">写入</font><font color="#800080">"</font><font color="#994300">&nbsp;id</font><font color="#800080">="</font><font color="#1A1AA6">btn</font><font color="#800080">"</font><font color="#994300">&nbsp;</font><font color="#800080">/&gt;</font><br><font color="#800080">&lt;script</font><font color="#800080">&gt;</font><br><font color="#5555AA">window</font>.indexedDB=<font color="#5555AA">window</font>.indexedDB||<font color="#5555AA">window</font>.webkitIndexedDB;<br><font color="#333388">var</font>&nbsp;cn,db;<br>cn=indexedDB.open(<font color="#AA5544">"MyDB"</font>,<font color="#CC3322">1</font>);<br>cn.onupgradeneeded=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;db=e.target.result;<br>&nbsp;&nbsp;db.createObjectStore(<font color="#AA5544">"MyOBJ"</font>,{autoIncrement:<font color="#DD6600">true</font>});<br>};<br>cn.onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;db=e.target.result;<br>};<br>btn.onclick=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;myOBJ=db.transaction([<font color="#AA5544">"MyOBJ"</font>],<font color="#AA5544">"readwrite"</font>).objectStore(<font color="#AA5544">"MyOBJ"</font>);<br>&nbsp;&nbsp;myOBJ.add({});<br>};<br><font color="#800080">&lt;/script&gt;</font></code>
　　看完这个代码，你是不是会想，为什么不把myOBJ也定义为全局变量呢？我一开始也是这么想的。你可以试着把代码这么改
<code><font color="#333388">var</font>&nbsp;myOBJ;<br>cn.onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;db=e.target.result;<br>&nbsp;&nbsp;myOBJ=db.transaction([<font color="#AA5544">"MyOBJ"</font>],<font color="#AA5544">"readwrite"</font>).objectStore(<font color="#AA5544">"MyOBJ"</font>);<br>};<br>btn.onclick=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;myOBJ.add({});<br>};</code>
　　看似逻辑很合理，但是改成这样后，点击“添加”按钮就会出错。
<code>Uncaught&nbsp;Error:&nbsp;TransactionInactiveError:&nbsp;DOM&nbsp;IDBDatabase&nbsp;Exception&nbsp;7</code>
　　这就是因为事务的生存周期已经过了，再执行事务中设置的对象就没有权限了。这个代码中，我们的事务是在数据库打开成功的事件中开始的。而这个事件运行结束后同步执行的代码就已经结束了，主线程被返回给浏览器，这样一个事务的生存周期也就结束了。这是我们点下按钮就会出现上面这个错，因为事务已经运行结束了。我们可以在这里给事务加上个执行完成的事件来测试。
<code>cn.onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;db=e.target.result;<br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;trans=db.transaction([<font color="#AA5544">"MyOBJ"</font>],<font color="#AA5544">"readwrite"</font>);<br>&nbsp;&nbsp;trans.oncomplete=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#5555AA">console.log</font>(<font color="#AA5544">"事务已执行完成"</font>);<br>&nbsp;&nbsp;};<br>&nbsp;&nbsp;myOBJ=trans.objectStore(<font color="#AA5544">"MyOBJ"</font>);<br>&nbsp;&nbsp;<font color="#5555AA">console.log</font>(<font color="#AA5544">"到这里事务还没执行完成"</font>);<br>};</code>
<img src="pictures/0db98f9b69cbac49496fe01ca20f8605.png" headerloaded="true"><br>
　　这个代码就是在创建事务的那个事件运行结束后调用事务的完成事件，当代码执行到事务所在事件的最后一句时事务都还在运行。因为这个性质，所以我们无法把整个事务对象或者事务里的存储对象定位为全局对象。由于每次要创建事务很麻烦，所以我在最初的那篇“<a href="article/20143.html" target="_blank">indexedDB的基本操作</a>”中自定义了个doTransaction方法来创建事务并执行代码。但是那篇文章里我只是做了非常简单的定义，如果需要更复杂的事务操作，就需要定义更复杂的方法。比如昨天的那篇“<a href="article/20144.html" target="_blank">indexedDB的存储对象结构设计</a>”用到了多个存储对象的同时操作，这时候如果有很多个地方用到存储对象的操作句应该定义更复杂的方法来操作。<br>
　　除了数据库的事务有这样的机制以外，在indexedDB中只要是事务的东西都有这样的机制，比如删除存储对象。
<code>cn.onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;db=e.target.result;<br>&nbsp;&nbsp;db.deleteObjectStore(<font color="#AA5544">"MyOBJ"</font>);<br>};</code>
　　这个代码尝试在数据库链接完成后删除存储对象，运行会抛出一个错误
<code>Uncaught&nbsp;Error:&nbsp;InvalidStateError:&nbsp;DOM&nbsp;IDBDatabase&nbsp;Exception&nbsp;11</code>
　　和前面的原因差不多，因为这个删除存储对象的操作必须在数据库初始化的事务中执行。虽然数据库初始化这个事件并没有强调自己是一个事务，但是确实如此。
<code>cn.onupgradeneeded=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;db=e.target.result;<br>&nbsp;&nbsp;<font color="#998877">//创建两个存储对象</font><br>&nbsp;&nbsp;db.createObjectStore(<font color="#AA5544">"TAB1"</font>);<br>&nbsp;&nbsp;db.createObjectStore(<font color="#AA5544">"TAB2"</font>);<br>&nbsp;&nbsp;<font color="#998877">//删除TAB1这个存储对象</font><br>&nbsp;&nbsp;db.deleteObjectStore(<font color="#AA5544">"TAB1"</font>);<br>};</code>
　　这样删除就能成功（不要吐槽例子的SB= =。。），好啦，事务机制大概就是这样，今天先到这儿吧～<br>
<br>
参考：<br>
　　<a href="https://developer.mozilla.org/en-US/docs/IndexedDB/Using_IndexedDB" target="_blank" rel="nofollow">https://developer.mozilla.org/en-US/docs/IndexedDB/Using_IndexedDB</a><br>
　　<a href="http://msdn.microsoft.com/en-us/library/windows/apps/hh466139.aspx" target="_blank" rel="nofollow">http://msdn.microsoft.com/en-us/library/windows/apps/hh466139.aspx</a><br>
      </article>

      <article itemprop="articleBody">
　　之前的几篇一直都在说数据库本身的操作，对数据操作都是一笔带过的。其实数据的操作在indexedDB中也没什么难点，因为文档很全。我也只是参考文档把所有方法都试用一遍而已。indexedDB为数据操作提供了很多方法，现在我们就来将它们逐个击破吧。<br>
　　首先，咱来个方法截个图
<img src="pictures/184c884078ac985e8fd6b74242c2c4b6.png" headerloaded="true"><br>
　　这个是直接在Chrome控制台上截的图，MDN和MSDN上也都有（在本文的末尾有链接）。indexedDB毕竟不是SQL，所以没有SQL语句的操作，而是把对数据的操作都做成对象的方法。这个图上列出了存储对象的全部方法，createIndex、deleteIndex、index，这个三个是关于存储对象的索引操作，这篇就不说了。主要是：add、clear、count、delete、get、openCursor、put，这么几个方法。这些其实在之前的文章中就有用过一些，只是没有详细说明而已。我们先把打开和初始化数据库的代码写出来，后面的代码都是基于这个之上的。由于前面几篇中已经说的很详细了，这个打开和初始化数据库的代码就不注释了。<br>
<code><font color="#5555AA">window</font>.indexedDB=<font color="#5555AA">window</font>.indexedDB||<font color="#5555AA">window</font>.webkitIndexedDB;<br><font color="#333388">var</font>&nbsp;cn,db;<br>indexedDB.deleteDatabase(<font color="#AA5544">"MyDB"</font>);<br>cn=indexedDB.open(<font color="#AA5544">"MyDB"</font>,<font color="#CC3322">1</font>);<br>cn.onupgradeneeded=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;db=e.target.result;<br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;o=db.createObjectStore(<font color="#AA5544">"MyOBJ"</font>,{keyPath:<font color="#AA5544">"key"</font>});<br>&nbsp;&nbsp;o.createIndex(<font color="#AA5544">"值"</font>,<font color="#AA5544">"value"</font>,{unique:<font color="#DD6600">true</font>});<br>};<br>cn.onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;db=e.target.result;<br>&nbsp;&nbsp;db.doTransaction=<font color="#333388">function</font>(f){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;o=db.transaction(<font color="#AA5544">"MyOBJ"</font>,<font color="#AA5544">"readwrite"</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;o.onerror=<font color="#333388">function</font>(){<font color="#5555AA">console.log</font>(<font color="#AA5544">"事务运行错误"</font>)};<br>&nbsp;&nbsp;&nbsp;&nbsp;f(o.objectStore(<font color="#AA5544">"MyOBJ"</font>));<br>&nbsp;&nbsp;};<br>};</code>
　　首先来看看数据的写入。和普通的localStorage不同的是，indexedDB不仅可以存储字符串，还可以存储一些JavaScript对象。不过储存的对象必须是可复制的。当我们储存一个对象时，它是按值传递的，也就是克隆一个对象副本传递进去。关于对象的可复制性，请参考这篇文章“<a href="article/20147.html" target="_blank">hasOwnProperty与对象的可复制性</a>”。
<code><font color="#800080">&lt;input</font><font color="#994300">&nbsp;type</font><font color="#800080">="</font><font color="#1A1AA6">button</font><font color="#800080">"</font><font color="#994300">&nbsp;value</font><font color="#800080">="</font><font color="#1A1AA6">添加数据</font><font color="#800080">"</font><font color="#994300">&nbsp;id</font><font color="#800080">="</font><font color="#1A1AA6">btn_add</font><font color="#800080">"</font><font color="#994300">&nbsp;</font><font color="#800080">/&gt;</font><br><font color="#800080">&lt;script</font><font color="#800080">&gt;</font><br><font color="#998877">//这里放置打开和初始化数据库的代码</font><br><br>btn_add.onclick=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;db.doTransaction(<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//清空存储对象内原来的数据</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.clear();<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//写入下列数据</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"对象"</font>,value:{}});<br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"数组"</font>,value:[]});<br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"数字"</font>,value:<font color="#CC3322">3.14</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"布尔"</font>,value:<font color="#DD6600">true</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"字符串"</font>,value:<font color="#AA5544">"次碳酸钴"</font>});<br>&nbsp;&nbsp;});<br>};<br><font color="#800080">&lt;/script&gt;</font></code>
<img src="pictures/d53d3b4c0592e11d134cda6b3493593e.png" headerloaded="true" width="596" style="cursor: pointer;"><br>
　　上面这只是例子，可以存储的对象当然不止这些了，所有可复制的对象都可以储存。现在不纠结这个，来看看另一个写入数据的方法put。我们一直都在使用add，就像它的名字一样它是用来添加记录的。但是，使用add添加记录时，当遇到主键约束或唯一约束时就会让事务进入错误回调中。put一样是添加记录，而它在处理主键约束时不是跳过而是覆盖原来的。但它也仅限于主键约束，对于普通索引的唯一约束它也无法正常工作。<br>
<code><font color="#800080">&lt;input</font><font color="#994300">&nbsp;type</font><font color="#800080">="</font><font color="#1A1AA6">button</font><font color="#800080">"</font><font color="#994300">&nbsp;value</font><font color="#800080">="</font><font color="#1A1AA6">add主键约束</font><font color="#800080">"</font><font color="#994300">&nbsp;id</font><font color="#800080">="</font><font color="#1A1AA6">btn_test1</font><font color="#800080">"</font><font color="#994300">&nbsp;</font><font color="#800080">/&gt;</font><br><font color="#800080">&lt;input</font><font color="#994300">&nbsp;type</font><font color="#800080">="</font><font color="#1A1AA6">button</font><font color="#800080">"</font><font color="#994300">&nbsp;value</font><font color="#800080">="</font><font color="#1A1AA6">put主键约束</font><font color="#800080">"</font><font color="#994300">&nbsp;id</font><font color="#800080">="</font><font color="#1A1AA6">btn_test2</font><font color="#800080">"</font><font color="#994300">&nbsp;</font><font color="#800080">/&gt;</font><br><font color="#800080">&lt;input</font><font color="#994300">&nbsp;type</font><font color="#800080">="</font><font color="#1A1AA6">button</font><font color="#800080">"</font><font color="#994300">&nbsp;value</font><font color="#800080">="</font><font color="#1A1AA6">put唯一约束</font><font color="#800080">"</font><font color="#994300">&nbsp;id</font><font color="#800080">="</font><font color="#1A1AA6">btn_test3</font><font color="#800080">"</font><font color="#994300">&nbsp;</font><font color="#800080">/&gt;</font><br><font color="#800080">&lt;script</font><font color="#800080">&gt;</font><br><font color="#998877">//这里放置打开和初始化数据库的代码</font><br><br>btn_test1.onclick=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;db.doTransaction(<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;e.clear();<br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"a"</font>,value:<font color="#CC3322">1</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"a"</font>,value:<font color="#CC3322">2</font>});<br>&nbsp;&nbsp;});<br>};<br>btn_test2.onclick=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;db.doTransaction(<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;e.clear();<br>&nbsp;&nbsp;&nbsp;&nbsp;e.put({key:<font color="#AA5544">"b"</font>,value:<font color="#CC3322">4</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;e.put({key:<font color="#AA5544">"b"</font>,value:<font color="#CC3322">5</font>});<br>&nbsp;&nbsp;});<br>};<br>btn_test3.onclick=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;db.doTransaction(<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;e.clear();<br>&nbsp;&nbsp;&nbsp;&nbsp;e.put({key:<font color="#AA5544">"c"</font>,value:<font color="#CC3322">0</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;e.put({key:<font color="#AA5544">"d"</font>,value:<font color="#CC3322">0</font>});<br>&nbsp;&nbsp;});<br>};<br><font color="#800080">&lt;/script&gt;</font></code>
　　这个测试结果比较多，我就不截图了。添加记录的问题大概就是这些，下面来说说读取记录。既然是key-value储存的，我当然是用key来读取记录了，系统有提供get方法，可以直接get一个key来获取相应的记录。但是要注意的是，indexedDB始终离不开的一点就是异步，即使仅仅是读取一条记录也需要异步。下面是代码
<code><font color="#800080">&lt;input</font><font color="#994300">&nbsp;type</font><font color="#800080">="</font><font color="#1A1AA6">button</font><font color="#800080">"</font><font color="#994300">&nbsp;value</font><font color="#800080">="</font><font color="#1A1AA6">测试</font><font color="#800080">"</font><font color="#994300">&nbsp;id</font><font color="#800080">="</font><font color="#1A1AA6">btn_test</font><font color="#800080">"</font><font color="#994300">&nbsp;</font><font color="#800080">/&gt;</font><br><font color="#800080">&lt;script</font><font color="#800080">&gt;</font><br><font color="#998877">//这里放置打开和初始化数据库的代码</font><br><br>btn_test.onclick=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;db.doTransaction(<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;e.clear();<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//先插入一条记录以便读取</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"a"</font>,value:<font color="#AA5544">"次碳酸钴"</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//读取a，这个记录存在可以读取到数据</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.get(<font color="#AA5544">"a"</font>).onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;o=e.target.result;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#5555AA">console.log</font>(o);<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//这个不存在，只能读取到undefined</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.get(<font color="#AA5544">"b"</font>).onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;o=e.target.result;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#5555AA">console.log</font>(o);<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;});<br>};<br><font color="#800080">&lt;/script&gt;</font></code>
<img src="pictures/bc9808ed4399e3f5597f4bbd166931e8.png" headerloaded="true"><br>
　　根据主键来读取一条记录很简单，只是要注意是异步，操作起来有点麻烦。下面是记录的遍历，这个其实在“<a href="article/20143.html" target="_blank">indexedDB的基本操作</a>”中就已经演示过了，这里就不重复了。实际上遍历是很复杂的行为，这个将在以后的文章中介绍。最后是几个简单的方法count、delete、clear。clear这个方法我们在上面的代码中已经用过了，就是清除存储对象的数据而已，没有什么特别的地方。最后是count和delete
<code><font color="#800080">&lt;input</font><font color="#994300">&nbsp;type</font><font color="#800080">="</font><font color="#1A1AA6">button</font><font color="#800080">"</font><font color="#994300">&nbsp;value</font><font color="#800080">="</font><font color="#1A1AA6">测试</font><font color="#800080">"</font><font color="#994300">&nbsp;id</font><font color="#800080">="</font><font color="#1A1AA6">btn_test</font><font color="#800080">"</font><font color="#994300">&nbsp;</font><font color="#800080">/&gt;</font><br><font color="#800080">&lt;script</font><font color="#800080">&gt;</font><br><font color="#998877">//这里放置打开和初始化数据库的代码</font><br><br>btn_test.onclick=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;db.doTransaction(<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;e.clear();<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//先插入几条记录</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"a"</font>,value:<font color="#CC3322">1</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"b"</font>,value:<font color="#CC3322">2</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"c"</font>,value:<font color="#CC3322">3</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//输出记录条数&nbsp;输出3</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.count().onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#5555AA">console.log</font>(e.target.result);<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//删除主键为b的记录</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.<font color="#333388">delete</font>(<font color="#AA5544">"b"</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//输出记录条数&nbsp;由于b被删除了，剩下两条记录&nbsp;输出2</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.count().onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#5555AA">console.log</font>(e.target.result);<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;});<br>};<br><font color="#800080">&lt;/script&gt;</font></code>
　　这个结果只是简单的两个数字而已，我也不截图了。以上就是indexedDB的数据操作。关键的关键就是记住一条，一切皆异步，再简单的操作咱都要异步的来。<br>
<br>
参考：<br>
　　<a href="https://developer.mozilla.org/en-US/docs/IndexedDB/IDBObjectStore" target="_blank" rel="nofollow">https://developer.mozilla.org/en-US/docs/IndexedDB/IDBObjectStore</a><br>
　　<a href="http://msdn.microsoft.com/en-us/library/windows/apps/hh465965.aspx" target="_blank" rel="nofollow">http://msdn.microsoft.com/en-us/library/windows/apps/hh465965.aspx</a><br>
      </article>


      <article itemprop="articleBody">
　　indexedDB的数据库结构一般是在创建数据库时设计好的。当我们创建数据库时会触发upgradeneeded事件，它相当于一个事务，我们可以在里面设计数据库结构。但是upgradeneeded事件对已经创建好的数据库不触发，那我们要如何修改数据库结构呢？<br>
　　要打开一个indexedDB我们需要调用open方法，open方法有两个参数，数据库名和版本号。实际上必要参数只要一个数据库名，版本号是可选参数。这就奇怪了，这个版本号到底是个啥？是indexedDB的版本？不，indexedDB哪有什么版本号！现代对象都是霸道升级主义的，他们不需要版本号。这里的版本号是开发者自己为数据库结构标识提供的版本号。看upgradeneeded这个事件的名称，upgrade needed，是指需要升级。我们创建数据库时候让它从0级升到指定了的等级就是一次升级，所以在创建数据库时会触发它。那么我们只要提升open时数据库的版本号就可以触发这个事件。<br>
<code><font color="#998877">//这个演示涉及到本地存储，所以就不做在线运行的版本了</font><br><br><font color="#998877">//尝试删除数据库MyDB</font><br>indexedDB.deleteDatabase(<font color="#AA5544">"MyDB"</font>);<br><br><font color="#998877">//后面定义了三个动作，他们会被链式的打开和关闭</font><br>test1();&nbsp;<font color="#998877">//从test1开始调用</font><br><br><font color="#333388">function</font>&nbsp;test1(){<br>&nbsp;&nbsp;<font color="#998877">//首次打开（默认版本号是最高版本）</font><br>&nbsp;&nbsp;indexedDB.open(<font color="#AA5544">"MyDB"</font>).onupgradeneeded=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//创建Obj1对象存储</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.target.result.createObjectStore(<font color="#AA5544">"Obj1"</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;e.target.result.close();<br>&nbsp;&nbsp;&nbsp;&nbsp;test2();<br>&nbsp;&nbsp;};<br>};<br><font color="#333388">function</font>&nbsp;test2(){<br>&nbsp;&nbsp;<font color="#998877">//再次打开，设置版本号为2</font><br>&nbsp;&nbsp;indexedDB.open(<font color="#AA5544">"MyDB"</font>,<font color="#CC3322">2</font>).onupgradeneeded=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//创建Obj2对象存储</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.target.result.createObjectStore(<font color="#AA5544">"Obj2"</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;e.target.result.close();<br>&nbsp;&nbsp;&nbsp;&nbsp;test3();<br>&nbsp;&nbsp;};<br>};<br><font color="#333388">function</font>&nbsp;test3(){<br>&nbsp;&nbsp;<font color="#998877">//再加一个版本号重新打开</font><br>&nbsp;&nbsp;indexedDB.open(<font color="#AA5544">"MyDB"</font>,<font color="#CC3322">3</font>).onupgradeneeded=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//尝试再次创建Obj2对象存储</font><br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">try</font>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.target.result.createObjectStore(<font color="#AA5544">"Obj2"</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<font color="#333388">catch</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//由于Obj2对象已经存在，此处会抛出异常</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#5555AA">console.log</font>(e.message);<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;e.target.result.close();<br>&nbsp;&nbsp;};<br>};</code>
<img src="pictures/ad1f58eb163e020d734453657f00645c.png" headerloaded="true"><br>
　　虽然我们可以修改数据库，但也要合理操作，避免创建已经存在的数据库和删除不存在的数据库等这样的错误。最后还有个问题，我们现在把数据库弄到了第3版，那打开旧版本会怎么样呢？上面的演示最后并没有删除掉数据库，我们接着测试。<br>
<code><font color="#333388">var</font>&nbsp;cn=indexedDB.open(<font color="#AA5544">"MyDB"</font>,<font color="#CC3322">1</font>);<br>cn.onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;<font color="#5555AA">console.log</font>(e.target.result);<br>};<br>cn.onerror=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;<font color="#5555AA">console.log</font>(e);<br>};</code>
<img src="pictures/1bef9648957649b8418bb73ec646b142.png" headerloaded="true"><br>
　　结果是打不开！数据库提升版本后我们无法使用旧版本。这会触发连接的error事件，火狐下还会直接在open的地方抛出异常。
      </article>


      <article itemprop="articleBody">
　　之前的几篇一直都在说数据库本身的操作，对数据操作都是一笔带过的。其实数据的操作在indexedDB中也没什么难点，因为文档很全。我也只是参考文档把所有方法都试用一遍而已。indexedDB为数据操作提供了很多方法，现在我们就来将它们逐个击破吧。<br>
　　首先，咱来个方法截个图
<img src="pictures/184c884078ac985e8fd6b74242c2c4b6.png" headerloaded="true"><br>
　　这个是直接在Chrome控制台上截的图，MDN和MSDN上也都有（在本文的末尾有链接）。indexedDB毕竟不是SQL，所以没有SQL语句的操作，而是把对数据的操作都做成对象的方法。这个图上列出了存储对象的全部方法，createIndex、deleteIndex、index，这个三个是关于存储对象的索引操作，这篇就不说了。主要是：add、clear、count、delete、get、openCursor、put，这么几个方法。这些其实在之前的文章中就有用过一些，只是没有详细说明而已。我们先把打开和初始化数据库的代码写出来，后面的代码都是基于这个之上的。由于前面几篇中已经说的很详细了，这个打开和初始化数据库的代码就不注释了。<br>
<code><font color="#5555AA">window</font>.indexedDB=<font color="#5555AA">window</font>.indexedDB||<font color="#5555AA">window</font>.webkitIndexedDB;<br><font color="#333388">var</font>&nbsp;cn,db;<br>indexedDB.deleteDatabase(<font color="#AA5544">"MyDB"</font>);<br>cn=indexedDB.open(<font color="#AA5544">"MyDB"</font>,<font color="#CC3322">1</font>);<br>cn.onupgradeneeded=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;db=e.target.result;<br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;o=db.createObjectStore(<font color="#AA5544">"MyOBJ"</font>,{keyPath:<font color="#AA5544">"key"</font>});<br>&nbsp;&nbsp;o.createIndex(<font color="#AA5544">"值"</font>,<font color="#AA5544">"value"</font>,{unique:<font color="#DD6600">true</font>});<br>};<br>cn.onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;db=e.target.result;<br>&nbsp;&nbsp;db.doTransaction=<font color="#333388">function</font>(f){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;o=db.transaction(<font color="#AA5544">"MyOBJ"</font>,<font color="#AA5544">"readwrite"</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;o.onerror=<font color="#333388">function</font>(){<font color="#5555AA">console.log</font>(<font color="#AA5544">"事务运行错误"</font>)};<br>&nbsp;&nbsp;&nbsp;&nbsp;f(o.objectStore(<font color="#AA5544">"MyOBJ"</font>));<br>&nbsp;&nbsp;};<br>};</code>
　　首先来看看数据的写入。和普通的localStorage不同的是，indexedDB不仅可以存储字符串，还可以存储一些JavaScript对象。不过储存的对象必须是可复制的。当我们储存一个对象时，它是按值传递的，也就是克隆一个对象副本传递进去。关于对象的可复制性，请参考这篇文章“<a href="article/20147.html" target="_blank">hasOwnProperty与对象的可复制性</a>”。
<code><font color="#800080">&lt;input</font><font color="#994300">&nbsp;type</font><font color="#800080">="</font><font color="#1A1AA6">button</font><font color="#800080">"</font><font color="#994300">&nbsp;value</font><font color="#800080">="</font><font color="#1A1AA6">添加数据</font><font color="#800080">"</font><font color="#994300">&nbsp;id</font><font color="#800080">="</font><font color="#1A1AA6">btn_add</font><font color="#800080">"</font><font color="#994300">&nbsp;</font><font color="#800080">/&gt;</font><br><font color="#800080">&lt;script</font><font color="#800080">&gt;</font><br><font color="#998877">//这里放置打开和初始化数据库的代码</font><br><br>btn_add.onclick=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;db.doTransaction(<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//清空存储对象内原来的数据</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.clear();<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//写入下列数据</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"对象"</font>,value:{}});<br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"数组"</font>,value:[]});<br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"数字"</font>,value:<font color="#CC3322">3.14</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"布尔"</font>,value:<font color="#DD6600">true</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"字符串"</font>,value:<font color="#AA5544">"次碳酸钴"</font>});<br>&nbsp;&nbsp;});<br>};<br><font color="#800080">&lt;/script&gt;</font></code>
<img src="pictures/d53d3b4c0592e11d134cda6b3493593e.png" headerloaded="true" width="596" style="cursor: pointer;"><br>
　　上面这只是例子，可以存储的对象当然不止这些了，所有可复制的对象都可以储存。现在不纠结这个，来看看另一个写入数据的方法put。我们一直都在使用add，就像它的名字一样它是用来添加记录的。但是，使用add添加记录时，当遇到主键约束或唯一约束时就会让事务进入错误回调中。put一样是添加记录，而它在处理主键约束时不是跳过而是覆盖原来的。但它也仅限于主键约束，对于普通索引的唯一约束它也无法正常工作。<br>
<code><font color="#800080">&lt;input</font><font color="#994300">&nbsp;type</font><font color="#800080">="</font><font color="#1A1AA6">button</font><font color="#800080">"</font><font color="#994300">&nbsp;value</font><font color="#800080">="</font><font color="#1A1AA6">add主键约束</font><font color="#800080">"</font><font color="#994300">&nbsp;id</font><font color="#800080">="</font><font color="#1A1AA6">btn_test1</font><font color="#800080">"</font><font color="#994300">&nbsp;</font><font color="#800080">/&gt;</font><br><font color="#800080">&lt;input</font><font color="#994300">&nbsp;type</font><font color="#800080">="</font><font color="#1A1AA6">button</font><font color="#800080">"</font><font color="#994300">&nbsp;value</font><font color="#800080">="</font><font color="#1A1AA6">put主键约束</font><font color="#800080">"</font><font color="#994300">&nbsp;id</font><font color="#800080">="</font><font color="#1A1AA6">btn_test2</font><font color="#800080">"</font><font color="#994300">&nbsp;</font><font color="#800080">/&gt;</font><br><font color="#800080">&lt;input</font><font color="#994300">&nbsp;type</font><font color="#800080">="</font><font color="#1A1AA6">button</font><font color="#800080">"</font><font color="#994300">&nbsp;value</font><font color="#800080">="</font><font color="#1A1AA6">put唯一约束</font><font color="#800080">"</font><font color="#994300">&nbsp;id</font><font color="#800080">="</font><font color="#1A1AA6">btn_test3</font><font color="#800080">"</font><font color="#994300">&nbsp;</font><font color="#800080">/&gt;</font><br><font color="#800080">&lt;script</font><font color="#800080">&gt;</font><br><font color="#998877">//这里放置打开和初始化数据库的代码</font><br><br>btn_test1.onclick=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;db.doTransaction(<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;e.clear();<br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"a"</font>,value:<font color="#CC3322">1</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"a"</font>,value:<font color="#CC3322">2</font>});<br>&nbsp;&nbsp;});<br>};<br>btn_test2.onclick=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;db.doTransaction(<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;e.clear();<br>&nbsp;&nbsp;&nbsp;&nbsp;e.put({key:<font color="#AA5544">"b"</font>,value:<font color="#CC3322">4</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;e.put({key:<font color="#AA5544">"b"</font>,value:<font color="#CC3322">5</font>});<br>&nbsp;&nbsp;});<br>};<br>btn_test3.onclick=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;db.doTransaction(<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;e.clear();<br>&nbsp;&nbsp;&nbsp;&nbsp;e.put({key:<font color="#AA5544">"c"</font>,value:<font color="#CC3322">0</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;e.put({key:<font color="#AA5544">"d"</font>,value:<font color="#CC3322">0</font>});<br>&nbsp;&nbsp;});<br>};<br><font color="#800080">&lt;/script&gt;</font></code>
　　这个测试结果比较多，我就不截图了。添加记录的问题大概就是这些，下面来说说读取记录。既然是key-value储存的，我当然是用key来读取记录了，系统有提供get方法，可以直接get一个key来获取相应的记录。但是要注意的是，indexedDB始终离不开的一点就是异步，即使仅仅是读取一条记录也需要异步。下面是代码
<code><font color="#800080">&lt;input</font><font color="#994300">&nbsp;type</font><font color="#800080">="</font><font color="#1A1AA6">button</font><font color="#800080">"</font><font color="#994300">&nbsp;value</font><font color="#800080">="</font><font color="#1A1AA6">测试</font><font color="#800080">"</font><font color="#994300">&nbsp;id</font><font color="#800080">="</font><font color="#1A1AA6">btn_test</font><font color="#800080">"</font><font color="#994300">&nbsp;</font><font color="#800080">/&gt;</font><br><font color="#800080">&lt;script</font><font color="#800080">&gt;</font><br><font color="#998877">//这里放置打开和初始化数据库的代码</font><br><br>btn_test.onclick=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;db.doTransaction(<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;e.clear();<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//先插入一条记录以便读取</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"a"</font>,value:<font color="#AA5544">"次碳酸钴"</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//读取a，这个记录存在可以读取到数据</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.get(<font color="#AA5544">"a"</font>).onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;o=e.target.result;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#5555AA">console.log</font>(o);<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//这个不存在，只能读取到undefined</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.get(<font color="#AA5544">"b"</font>).onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;o=e.target.result;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#5555AA">console.log</font>(o);<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;});<br>};<br><font color="#800080">&lt;/script&gt;</font></code>
<img src="pictures/bc9808ed4399e3f5597f4bbd166931e8.png" headerloaded="true"><br>
　　根据主键来读取一条记录很简单，只是要注意是异步，操作起来有点麻烦。下面是记录的遍历，这个其实在“<a href="article/20143.html" target="_blank">indexedDB的基本操作</a>”中就已经演示过了，这里就不重复了。实际上遍历是很复杂的行为，这个将在以后的文章中介绍。最后是几个简单的方法count、delete、clear。clear这个方法我们在上面的代码中已经用过了，就是清除存储对象的数据而已，没有什么特别的地方。最后是count和delete
<code><font color="#800080">&lt;input</font><font color="#994300">&nbsp;type</font><font color="#800080">="</font><font color="#1A1AA6">button</font><font color="#800080">"</font><font color="#994300">&nbsp;value</font><font color="#800080">="</font><font color="#1A1AA6">测试</font><font color="#800080">"</font><font color="#994300">&nbsp;id</font><font color="#800080">="</font><font color="#1A1AA6">btn_test</font><font color="#800080">"</font><font color="#994300">&nbsp;</font><font color="#800080">/&gt;</font><br><font color="#800080">&lt;script</font><font color="#800080">&gt;</font><br><font color="#998877">//这里放置打开和初始化数据库的代码</font><br><br>btn_test.onclick=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;db.doTransaction(<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;e.clear();<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//先插入几条记录</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"a"</font>,value:<font color="#CC3322">1</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"b"</font>,value:<font color="#CC3322">2</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;e.add({key:<font color="#AA5544">"c"</font>,value:<font color="#CC3322">3</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//输出记录条数&nbsp;输出3</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.count().onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#5555AA">console.log</font>(e.target.result);<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//删除主键为b的记录</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.<font color="#333388">delete</font>(<font color="#AA5544">"b"</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//输出记录条数&nbsp;由于b被删除了，剩下两条记录&nbsp;输出2</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.count().onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#5555AA">console.log</font>(e.target.result);<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;});<br>};<br><font color="#800080">&lt;/script&gt;</font></code>
　　这个结果只是简单的两个数字而已，我也不截图了。以上就是indexedDB的数据操作。关键的关键就是记住一条，一切皆异步，再简单的操作咱都要异步的来。<br>
<br>
参考：<br>
　　<a href="https://developer.mozilla.org/en-US/docs/IndexedDB/IDBObjectStore" target="_blank" rel="nofollow">https://developer.mozilla.org/en-US/docs/IndexedDB/IDBObjectStore</a><br>
　　<a href="http://msdn.microsoft.com/en-us/library/windows/apps/hh465965.aspx" target="_blank" rel="nofollow">http://msdn.microsoft.com/en-us/library/windows/apps/hh465965.aspx</a><br>
      </article>


      <article itemprop="articleBody">
　　在indexedDB中需要查询多条数据，或者说遍历数据，就得用游标（Cursor）。它通过存储对象或索引对象上的openCursor方法来创建。这个方法虽然只有两个参数，但是很复杂，与上一篇的索引关系非常密切。游标的作用就是通过索引来遍历并筛选数据。<br>
　　为了测试，我们先创建这样一个索引结构的数据，并添加数据
<code><font color="#333388">var</font>&nbsp;db,cn=indexedDB.open(<font color="#AA5544">"MyDB"</font>);<br>indexedDB.deleteDatabase(<font color="#AA5544">"MyDB"</font>);<br>cn.onupgradeneeded=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;db=e.target.result;<br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;obj=db.createObjectStore(<font color="#AA5544">"MyOBJ"</font>,{keyPath:<font color="#AA5544">"id"</font>});<br>&nbsp;&nbsp;obj.createIndex(<font color="#AA5544">"a"</font>,<font color="#AA5544">"a"</font>);<br>&nbsp;&nbsp;obj.createIndex(<font color="#AA5544">"b"</font>,<font color="#AA5544">"b"</font>);<br>&nbsp;&nbsp;obj.createIndex(<font color="#AA5544">"ab"</font>,[<font color="#AA5544">"a"</font>,<font color="#AA5544">"b"</font>]);<br>};<br>cn.addEventListener(<font color="#AA5544">"success"</font>,<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;i,transaction,obj;<br>&nbsp;&nbsp;db=e.target.result;<br>&nbsp;&nbsp;transaction=db.transaction(<font color="#AA5544">"MyOBJ"</font>,<font color="#AA5544">"readwrite"</font>);<br>&nbsp;&nbsp;obj=transaction.objectStore(<font color="#AA5544">"MyOBJ"</font>);<br>&nbsp;&nbsp;<font color="#998877">//添加测试数据</font><br>&nbsp;&nbsp;<font color="#333388">for</font>(i=<font color="#CC3322">0</font>;i&lt;<font color="#CC3322">12</font>;i++)obj.put({id:i,a:i%<font color="#CC3322">4</font>,b:<font color="#5555AA">Math</font>.random()});<br>});</code>
　　存储对象上直接就有openCursor方法，我们可以不使用索引直接遍历数据。这在<a href="article/20143.html" target="_blank">indexedDB(壹)</a>篇中就演示过了，这种方式是根据主键来排序的。这篇中我们要强调的是条件与排序。排序很简单，和上一篇中的截图一样，索引对象已经把数据排好序了。indexedDB中的索引不仅类似SQL中的索引，还与SQL中的视图有一点点相似之处。如果不介意，可以把它暂时看做是一个以某个字段排序的视图。那么，我们只要从这个视图中读取数据便可以按照相应顺序访问。
<code>cn.addEventListener(<font color="#AA5544">"success"</font>,<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;i,transaction,obj,ind;<br>&nbsp;&nbsp;db=e.target.result;<br>&nbsp;&nbsp;transaction=db.transaction(<font color="#AA5544">"MyOBJ"</font>,<font color="#AA5544">"readwrite"</font>);<br>&nbsp;&nbsp;obj=transaction.objectStore(<font color="#AA5544">"MyOBJ"</font>);<br>&nbsp;&nbsp;ind=obj.index(<font color="#AA5544">"b"</font>);&nbsp;<font color="#998877">//从存储对象中获取b这个索引对象</font><br>&nbsp;&nbsp;<font color="#5555AA">console.log</font>(<font color="#AA5544">"开始遍历："</font>);<br>&nbsp;&nbsp;<font color="#998877">//从b索引对象中遍历数据</font><br>&nbsp;&nbsp;ind.openCursor().onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">if</font>(e=e.target.result){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#5555AA">console.log</font>(e.value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.<font color="#333388">continue</font>();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<font color="#333388">else</font>&nbsp;<font color="#5555AA">console.log</font>(<font color="#AA5544">"遍历完毕！"</font>);<br>&nbsp;&nbsp;};<br>});</code>
<img src="pictures/87e8957426035340c5e063e26d44ed97.png" headerloaded="true"><br>
　　由于b索引是b字段的索引，而b字段在写入数据时我们用了随机数，所以按照b字段排序的话就会得到一片混乱的结果。不过知悉看b字段是被从小到大排序好的。当然我们也可以用倒序来排列，这在openCursor的参数中指定。<br>
　　openCursor方法有两个参数。第一个是条件，默认值为null；第二个是排序，默认值为next表示从小到大排序，可以设置成prev来让结果倒序排列，类似SQL中的ASC和DESC。第二个参数比较简单，我就不演示了。openCursor的难点在于第一个参数！<br>
　　我们如果对输出的数据进行筛选呢？在indexedDB中这个功能比较弱，我们无法像SQL那样自己写个复杂的条件表达式。我们每次只能选择一个索引，所以条件也只能针对这个选中的索引来设置。而且，我们无法直接使用条件表达式，必须使用已经对象化好的东西——IDBKeyRange对象。这个对象不是作为构造器使用的，而是调用上面的静态方法。它有这么几个方法：<br>
　　　　<strong>IDBKeyRange.lowerBound(any,bool)</strong><br>
　　　　<strong>IDBKeyRange.upperBound(any,bool)</strong><br>
　　　　<strong>IDBKeyRange.bound(any,any,bool,bool)</strong><br>
　　　　<strong>IDBKeyRange.only(any)</strong><br>
　　别看这些方法乱糟糟的，其实很简单。他们只是为了定义一个区间而已，脑子里只要有一条数轴就OK。lower是左边界，upper是右边界。如果我们需要的区间之后一个边界，另一边是无穷大或无穷小，就可以时候lowerBound或upperBound来实现，他们的第一个参数就是相应边界的位置；第二个参数是一个布尔值，用于表示这个边界是开的还是闭的，或者说是包含给定值还是不包含给定值。默认值是false也就是包含指定值，比如
<code>IDBKeyRange.lowerBound(<font color="#CC3322">2</font>,<font color="#DD6600">false</font>);&nbsp;<font color="#998877">//大于或等于2</font><br>IDBKeyRange.lowerBound(<font color="#CC3322">2</font>,<font color="#DD6600">true</font>);&nbsp;<font color="#998877">//大于2</font></code>
　　当我们需要同时设置区间的上下界时候就用bound方法，参数类似上面的两个方法。最后一个only方法是判断相等，和使用bound时把前两个参数设置成相同的值是等价的。总之只要记住它是区间的概念就行。
<code>cn.addEventListener(<font color="#AA5544">"success"</font>,<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;i,transaction,obj,ind,range;<br>&nbsp;&nbsp;db=e.target.result;<br>&nbsp;&nbsp;transaction=db.transaction(<font color="#AA5544">"MyOBJ"</font>,<font color="#AA5544">"readwrite"</font>);<br>&nbsp;&nbsp;obj=transaction.objectStore(<font color="#AA5544">"MyOBJ"</font>);<br>&nbsp;&nbsp;ind=obj.index(<font color="#AA5544">"a"</font>);&nbsp;<font color="#998877">//从存储对象中获取b这个索引对象</font><br>&nbsp;&nbsp;<font color="#998877">//区间：[1,3)</font><br>&nbsp;&nbsp;range=IDBKeyRange.bound(<font color="#CC3322">1</font>,<font color="#CC3322">3</font>,<font color="#DD6600">false</font>,<font color="#DD6600">true</font>);<br>&nbsp;&nbsp;<font color="#5555AA">console.log</font>(<font color="#AA5544">"开始遍历："</font>);<br>&nbsp;&nbsp;<font color="#998877">//从a索引对象中遍历数据（倒序）</font><br>&nbsp;&nbsp;ind.openCursor(range,<font color="#AA5544">"prev"</font>).onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">if</font>(e=e.target.result){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#5555AA">console.log</font>(e.value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.<font color="#333388">continue</font>();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<font color="#333388">else</font>&nbsp;<font color="#5555AA">console.log</font>(<font color="#AA5544">"遍历完毕！"</font>);<br>&nbsp;&nbsp;};<br>});</code>
<img src="pictures/1a9a4bf6a1744b7243b8c2c5d5534f15.png" headerloaded="true"><br>
　　这个结果在a字段上包含1不包含3就是a∈[1,3)，而且用了倒序的方式，所以是从大到小的输出。但是条件设置并没这么简单，我们还要多字段索引的情况。注意IDBKeyRange提供的方法中，前面的参数都是任意类型的。如果一个索引设置了多个字段，它就会是一个数组，我们如果传入数组就是数组与数组的比较。但这不是传统意义上的数组比较，在JavaScript中数组会被转换成字符来比较。而indexedDB中，这里的数组比较使用的是一种类似排序的算法。这东西比较难解释，先来看程序吧
<code>cn.addEventListener(<font color="#AA5544">"success"</font>,<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;i,transaction,obj,ind,range;<br>&nbsp;&nbsp;db=e.target.result;<br>&nbsp;&nbsp;transaction=db.transaction(<font color="#AA5544">"MyOBJ"</font>,<font color="#AA5544">"readwrite"</font>);<br>&nbsp;&nbsp;obj=transaction.objectStore(<font color="#AA5544">"MyOBJ"</font>);<br>&nbsp;&nbsp;ind=obj.index(<font color="#AA5544">"ab"</font>);<br>&nbsp;&nbsp;range=IDBKeyRange.lowerBound([<font color="#CC3322">2</font>,<font color="#CC3322">0.5</font>]);<br>&nbsp;&nbsp;<font color="#5555AA">console.log</font>(<font color="#AA5544">"开始遍历："</font>);<br>&nbsp;&nbsp;ind.openCursor(range).onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">if</font>(e=e.target.result){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#5555AA">console.log</font>(e.value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.<font color="#333388">continue</font>();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<font color="#333388">else</font>&nbsp;<font color="#5555AA">console.log</font>(<font color="#AA5544">"遍历完毕！"</font>);<br>&nbsp;&nbsp;};<br>});</code>
<img src="pictures/2f3af396193f47df82e5d9be8a92291f.png" headerloaded="true"><br>
　　实际上我们的区间依然是个数轴，维度并没有因为数据的维度增加而增加，只是在比较的算法上做了一些处理。假设我们传入的参数是A，数据库中的数据是B。在比较时先对A[0]和B[0]做比较。如果A[0]大于或小于B[0]，那么只有两种情况，要么丢弃数据，要么使用数据，不会再做其它项的比较了。只有A[0]和B[0]相等时候才会去比较A[1]和B[1]，这就是我说的类似排序的算法。如果A[1]和B[1]也相等，那么才会根据我们在调用lowerBound时候设置的第二个布尔参数来判断。
      </article>


      <article itemprop="articleBody">
　　上一篇文章中已经说过了缺少lock带来的问题，并且告诉大家localStorage是不带lock功能的。那么要实现前端的数据共享并且需要lock功能那就需要使用其它本储存方式，比如indexedDB。indededDB使用的是事务处理的机制，那实际上就是lock功能。<br>
　　做这个测试需要先简单的封装下indexedDB的操作，因为indexedDB的连接比较麻烦，而且两个测试页面都需要用到
<code><font color="#998877">//db.js</font><br><font color="#998877">//封装事务操作</font><br>IDBDatabase.prototype.doTransaction=<font color="#333388">function</font>(f){<br>&nbsp;&nbsp;f(<font color="#333388">this</font>.transaction([<font color="#AA5544">"Obj"</font>],<font color="#AA5544">"readwrite"</font>).objectStore(<font color="#AA5544">"Obj"</font>));<br>};<br><font color="#998877">//连接数据库，成功后调用main函数</font><br>(<font color="#333388">function</font>(){<br>&nbsp;&nbsp;<font color="#998877">//打开数据库</font><br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;cn=indexedDB.open(<font color="#AA5544">"TestDB"</font>,<font color="#CC3322">1</font>);<br>&nbsp;&nbsp;<font color="#998877">//创建数据对象</font><br>&nbsp;&nbsp;cn.onupgradeneeded=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;e.target.result.createObjectStore(<font color="#AA5544">"Obj"</font>);<br>&nbsp;&nbsp;};<br>&nbsp;&nbsp;<font color="#998877">//数据库连接成功</font><br>&nbsp;&nbsp;cn.onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;main(e.target.result);<br>&nbsp;&nbsp;};<br>})();</code>
　　接着是两个测试页面
<code><font color="#800080">&lt;script</font><font color="#994300">&nbsp;src</font><font color="#800080">="</font><font color="#1A1AA6">db.js</font><font color="#800080">"</font><font color="#800080">&gt;</font><font color="#800080">&lt;/script&gt;</font><br><font color="#800080">&lt;script</font><font color="#800080">&gt;</font><br><font color="#998877">//a.html</font><br><font color="#333388">function</font>&nbsp;main(e){<br>&nbsp;&nbsp;(<font color="#333388">function</font>&nbsp;callee(){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//开始一个事务</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.doTransaction(<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.put(<font color="#CC3322">1</font>,<font color="#AA5544">"test"</font>);&nbsp;<font color="#998877">//设置test的值为1</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.put(<font color="#CC3322">2</font>,<font color="#AA5544">"test"</font>);&nbsp;<font color="#998877">//设置test的值为2</font><br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(callee);<br>&nbsp;&nbsp;})();<br>};<br><font color="#800080">&lt;/script&gt;</font></code>
<code><font color="#800080">&lt;script</font><font color="#994300">&nbsp;src</font><font color="#800080">="</font><font color="#1A1AA6">db.js</font><font color="#800080">"</font><font color="#800080">&gt;</font><font color="#800080">&lt;/script&gt;</font><br><font color="#800080">&lt;script</font><font color="#800080">&gt;</font><br><font color="#998877">//b.html</font><br><font color="#333388">function</font>&nbsp;main(e){<br>&nbsp;&nbsp;(<font color="#333388">function</font>&nbsp;callee(){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//开始一个事务</font><br>&nbsp;&nbsp;&nbsp;&nbsp;e.doTransaction(<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//获取test的值</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.get(<font color="#AA5544">"test"</font>).onsuccess=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#5555AA">console.log</font>(e.target.result);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(callee);<br>&nbsp;&nbsp;})();<br>};<br><font color="#800080">&lt;/script&gt;</font></code>
　　和上次localStorage的测试原理一样，只是把localStorage换成了indexedDB事务处理。但是结果就不同<br>
<img src="pictures/1d1b10afa10ca6adb6335ceb49a631c0.png" headerloaded="true"><br>
　　测试的时候b.html中可能不会立即有输出，因为indexedDB正忙着处理a.html东西，b.html事务丢在了事务丢队列中等待。但是无论如何，输出结果也不会是1这个值。因为indexedDB的最小处理单位是事务，而不是localStorage那样以表达式为单位。这样只要把lock和unlock之间需要处理的东西放入一个事务中即可实现。另外，浏览器对indexedDB的支持不如localStorage，所以使用时还得考虑浏览器兼容。<br>
      </article>


      <article itemprop="articleBody">
　　从IE10开始，它就支持了indexedDB。但IE不愧是IE，总是变着花样坑爹。在其它浏览器中indexedDB的事务是在一个JavaScript消息运行结束时被释放的。而IE上虽然也会如此释放，但它的释放很不及时，在之后的消息中有时依然可以使用先前消息中的事务。<br>
<code>indexedDB.deleteDatabase(<font color="#AA5544">"test"</font>);&nbsp;<font color="#998877">//尝试删除已存在的同名数据库</font><br>(<font color="#333388">function</font>(){<br>&nbsp;&nbsp;<font color="#998877">//初始化数据库结构</font><br>&nbsp;&nbsp;<font color="#333388">this</font>.onupgradeneeded=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">this</font>.result.createObjectStore(<font color="#AA5544">"myobj"</font>,{keyPath:<font color="#AA5544">"id"</font>});<br>&nbsp;&nbsp;};<br>&nbsp;&nbsp;<font color="#998877">//成功打开数据库</font><br>&nbsp;&nbsp;<font color="#333388">this</font>.onsuccess=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;db=<font color="#333388">this</font>.result,<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//为myobj存储对象创建一个可读写的事务</font><br>&nbsp;&nbsp;&nbsp;&nbsp;transaction=db.transaction(<font color="#AA5544">"myobj"</font>,<font color="#AA5544">"readwrite"</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//试图在计时器消息中使用刚才创建的事务来写入数据</font><br>&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(<font color="#333388">function</font>(){&nbsp;<font color="#998877">//创建新的计时器消息来执行</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transaction.objectStore(<font color="#AA5544">"myobj"</font>).put({id:<font color="#CC3322">0</font>,n:<font color="#AA5544">"坑了个爹"</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//读取id为0的那条数据</font><br>&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(<font color="#333388">function</font>(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db.transaction(<font color="#AA5544">"myobj"</font>,<font color="#AA5544">"readonly"</font>).objectStore(<font color="#AA5544">"myobj"</font>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.get(<font color="#CC3322">0</font>).onsuccess=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#5555AA">console.log</font>(<font color="#333388">this</font>.result&amp;&amp;<font color="#333388">this</font>.result.n);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;};<br>}).call(indexedDB.open(<font color="#AA5544">"test"</font>));&nbsp;<font color="#998877">//打开数据库</font></code>
　　这个测试在Chrome和Firefox上毫无悬念地报错了。<br>
<img src="pictures/8bbe21b0c62d31d5dafcd81fef6578f4.png" headerloaded="true"><br>
　　但在IE上会随机出现两种结果。<br>
<img src="pictures/caba233023cd118cf47993d8222c16d5.png" headerloaded="true"><br>
　　这会造成的后果是一个事务如果没有从创建到释放都一直盯着，我们就很难保证这个事务可以正常使用，因为它可能是其它消息中创建的事务。在一些可能需要合并到同一个事务中的零散操作，我们可能就需要一个事务池来实现。而IE的这个特性导致了无法判断事务的可用性，给事务池的实现带来了一些麻烦。
      </article>

      <article itemprop="articleBody">
　　indexedDB的基本操作是基于事务的，多个操作我们可能会在多个事务中完成。那么同一个消息中的事务数量有没有限制呢？通常情况下是不限制的，但Firefox却不同。当同时执行的事务超出一定数量后事务就会被强制终止，所以我们应该避免对事务的滥用。<br>
　　下面是重现这个问题的代码
<code>indexedDB.deleteDatabase(<font color="#AA5544">"test"</font>);&nbsp;<font color="#998877">//尝试删除已存在的同名数据库</font><br>(<font color="#333388">function</font>(){<br>&nbsp;&nbsp;<font color="#998877">//初始化数据库结构</font><br>&nbsp;&nbsp;<font color="#333388">this</font>.onupgradeneeded=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">this</font>.result.createObjectStore(<font color="#AA5544">"myobj"</font>,{keyPath:<font color="#AA5544">"id"</font>});<br>&nbsp;&nbsp;};<br>&nbsp;&nbsp;<font color="#998877">//成功打开数据库</font><br>&nbsp;&nbsp;<font color="#333388">this</font>.onsuccess=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;db=<font color="#333388">this</font>.result;<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//用100个事务分别写入数据</font><br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">for</font>(<font color="#333388">var</font>&nbsp;i=<font color="#CC3322">0</font>;i&lt;<font color="#CC3322">100</font>;i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db.transaction(<font color="#AA5544">"myobj"</font>,<font color="#AA5544">"readwrite"</font>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.objectStore(<font color="#AA5544">"myobj"</font>).put({id:i});<br>&nbsp;&nbsp;};<br>}).call(indexedDB.open(<font color="#AA5544">"test"</font>));&nbsp;<font color="#998877">//打开数据库</font></code>
<img src="pictures/8a94f0bbba65beb38ee43ae3ce80835a.png" headerloaded="true"><br>
　　也许第一次运行并不会出错，但是刷新页面后就可以看到错误。因为indededDB服务不是页面级的，事务可能不会因为页面的刷新而被释放。由于大量暂时还没释放的事务存在，所以后面再创建事务就没有多余的空间了。<br>
　　这个问题没有直接的解决办法，我们只能应该尽可能的避免使用太多事务，比如实现个事务池之类的东西来把零碎的操作合并到同一个事务中。其实本身就不应该开太多事务，即使在其它不会出现这个问题的浏览器上也一样！因为太多的事务只会影响性能。<br>
<br>
测试于：<br>
　　Firefox 26.0<br>
      </article>


      <article itemprop="articleBody">
　　程序通信越来越流行的今天，很多前端框架都已经基于程序通信来实现了。虽然我也很喜欢程序通信，但它也不是那么容易驾驭的。既然使用了程序通信，就相当于放弃了传统Web结构的一些自然优化。比如HTTP本身的一套缓存机制，就会因为程序通信而被弱化。<br>
　　但大多数API被设计成SOAP（大家都这么喜欢捡肥皂吗←_←）。由于从一个固定不变的URL上加载数据，为了防止客户端顽固缓存使用户无法查看到最新内容，客户端程序通常会使用POST方法（或者使用更糟糕的GET方法请求URL后加随机参数）。那么，传统Web结构原有的缓存机制就被破坏。如果直接使用这样的程序就可能造成比传统Web结构更大的网络开销。<br>
　　使用SOAP模式的Web结构就应该为序自己实现一套缓存机制（REST模式可以部分依赖HTTP缓存，但不建议如此）。而且既然是程序通信，那就可以实现比HTTP缓存更好的缓存机制。HTTP缓存总是针对一个完整的资源的，而程序通信的话，数据可以被分解到更细的单元再做缓存。比如一个数据列表，HTTP缓存是直接缓存整个列表，其中有任何数据变化都要重新加载。而程序缓存可以缓存到列表中的项，列表数据有变化时只要加载变化的项即可。甚至如果是REST的话可以做多级缓存，先让浏览器处理HTTP缓存，之后程序再进一步处理。<br>
　　最后总结一些要点：<strong>以程序通信主导的框架总是要有一个程序实现的缓存机制相佐，否则只会让程序的网络开销变得更大。</strong>程序实现缓存机制需要一些浏览器API的支持，比如localStorage、indexedDB等（本博客程序的缓存主要就使用indexedDB，可以在浏览器的开发人员工具中看到）。因此对于低版本浏览器而言，程序通信并不会带来什么优化，也许还适得其反。
      </article>

      <article itemprop="articleBody">
　　学习一个API不是把所有对象、属性、方法、事件、结构，全都记下来就行的。有些东西的数量多到一般人不能对其完全记忆，比如Win32API的数量就多且复杂到无法记忆。所以记住API并不是最重要的，最重要的是理解API的设计理念，试着体会API作者的想法。<br>
　　有人花很多时间去学习jQuery，网络上找的教程，只是教了各种特效的做法、各个方法的使用说明。这样学到的东西永远停留在看过的东西上。我觉得如果是为了使用就不该花时间去学那些东西，更应该想想作者为什么这么做。遇到问题应该想想John Resig如果遇到同样问题会怎么做。只要了解了作者的风格，那些API怎么着也可以猜到一二。比如了解了jQuery对象的css方法，那么attr方法和data方法就是一样的套路。当发现一些方法的返回值是jQuery对象时，对于新的方法也可以做这样的猜测。作者也想开发出更简单的东西降低使用者的学习成本，所以不可能把API设计的完全无逻辑。当然，以上这些并不是怂恿大家不要去学习，我想说的是，只为了学习如何使用它，就没必要生硬地去学习每个方法。如果是为了开发同类产品，研究其源码，学习它的实现还是很有帮助的。<br>
　　不仅是jQuery，也许这样的第三方库太没说服力了。实际上JavaScript内置对象的属性方法、DOM操作API，等，这些都是人开发的。比如我们看到一个叫做getAttribute的方法时应该就能猜到可能会有一个setAttribute与之对应。看到一个appendChild时就可以猜到可能会dependChild，但实际上并没有这个方法，只是通过这个名称可以找到removeChild方法。<br>
　　很多现代浏览器的新API，如，WebGL、IndexedDB、AudioAPI，等，这些东西都是不同的小组开发的，他们的设计理念都不同。有些作者喜欢函数式编程，整个API都是函数式的。有些作者喜欢事件式编程，整个API就被设计成事件式的。甚至有些作者还喜欢节点式编程，那么API就可以被设计成节点式的。其实我这里说的太主观了，有使用并不是作者喜欢这样的风格，而是作者觉得这样的风格更适合开发这套API。<br>
　　总之。只要知道了整个API的设计风格，学习它的其它东西就势如破竹。要把所有API都记住是基本不可能，也是浪费时间的。只有体会他们的设计理念，才能更灵活的使用它们。
      </article>

      <article itemprop="articleBody">
　　对服务器的带宽占用永远是Web程序的最大瓶颈，对程序最有效的优化就是减少带宽占用，于是有了lazyload，让一些使用不到的东西不直接加载，从而节约资源。不仅是针对某些资源使用lazyload，整个Web程序在设计上就应该把自己设计成类似的形式。<br>
　　传统Web基本是以页面跳转为基础的，程序只是用来处理页面上的小功能而已，这种类型的Web程序已经没有多少优化空间了。但现代Web程序更喜欢使用较少的页面展示更多东西，很多数据是通过程序通信加载的。这样的程序就可以被优化，我们只要减少不必要的程序通信就可以实现优化。于是我们有两种优化方式，一种是尽量减少对数据的需求（选择按需加载），另一种是尽量避免加载重复数据（使用本地缓存）。<br>
　　<strong>按需加载</strong>。数据按需加载在之前的文章中介绍过了<a target="_blank" class="link" href="article/20532.html"></a>。其实不仅是数据，程序也能按需加载。现代Web的一个页面通常都是继承了许多功能的，这些功能只是存在，但未必会被使用，所以对不必要的功能程序就可以按需加载。比如网站的登陆和注册模块如果是弹出一个对话框，那就可以把它独立处理，因为大部分时候用户会记住密码，不会多次使用到登陆模块。<br>
　　<strong>本地缓存</strong>。这里说的缓存不是指HTTP缓存，HTTP缓存是最基础的，就算是传统Web也会开启的。这里说的是localStorage或indexedDB等现代浏览器提供的本地储存API。程序可以把从服务器加载到的数据储存在本地，这些数据可以在前端有机地组织后使用，可以在多个页面、多个模块、以不同的形式展现给用户。比如商品列表的数据加载后可以做成排行榜、图表，等展示出来。<br>
　　
      </article>

      <article itemprop="articleBody">
　　JavaScript本身是单线程的，但它却是事件驱动的。类似Windows窗体应用程序，它也需要消息队列机制来实现。程序的执行并不是连续的，绝大多数时间都在等待消息。每次执行执行程序都是在响应消息，这样就可以把消息当作一种类似作用域的东西来处理。<br>
　　消息是什么？说白了就是事件，只是有很多系统事件是不需要我们自己来处理的。比如Paint事件，也许你听都没听过，这就是因为它没有在JavaScript中的接口。还有初始化事件，当一个JavaScript载入完成时，里面的代码就需要执行，这就是初始化事件触发的。也就是说，代码载入完成后会接收到一个初始化消息，这个消息的工作就是执行代码。初始化事件就涉及到了JavaScript，但是它的工作只是执行代码，我们无法指定它做别的事情。剩下的还有用户事件，比如鼠标事件、键盘事件、计时器事件，等这些是可以为它们指定动作的。<br>
　　现在回头来看单线程的JavaScript。其实说JavaScript单线程还不够确切，整个网页的工作都是单线程的，JavaScript只是其中之一。如果你在页面上放一个死循环，就会导致整个页面不响应，包括HTML和CSS都会不响应。当然有些组件是有自己的线程，所以不会被死循环影响，咱就不说它们了。那么，页面为什么不响应呢？这就是因为线程被死循环占用了。这时候，即使有消息传入（事件触发）也没有线程可以来运行事件的程序了。这些需要等待处理的消息就会被放入消息队列中，这个模式和Windows窗体应用程序是一样的。所以我们也对JavaScript引入消息机制这个概念。<br>
　　我之前一直都没意识到这个东西的重要性，所以没写这篇。但是很多东西都使用了消息机制的概念，如果不写这篇文章就无法在其它文章中描述清楚。之前的文章也有涉及到了消息机制的，比如“<a href="article/20145.html" target="_blank">indexedDB的事务机制</a>”，将要写的关于WebGL的文章也会用到这个。现在，咱先来看一段代码吧<br>
<code><font color="#333388">var</font>&nbsp;a=<font color="#CC3322">0</font>;<br>setTimeout(<font color="#333388">function</font>(){a++});<br><font color="#333388">for</font>(<font color="#333388">var</font>&nbsp;i=<font color="#CC3322">0</font>;i&lt;<font color="#CC3322">1E9</font>;i++);<br><font color="#5555AA">console.log</font>(a);&nbsp;<font color="#998877">//无论上面循环多少次都是输出0</font></code>
　　这个代码加载完成后，程序会收到它的初始化消息，也就是会运行这个代码。或者说，这个代码的运行就是在处理初始化消息。第二行的setTimeout会给当前程序发送一个计时器消息。但是当前线程正在处理初始化消息，哪有空理会这个新的消息呀？于是这个消息就暂时被放入消息队列中，等待初始化消息处理完成。第三行的for，无论循环多少次，它都是在初始化消息中的。就算这个循环是需要很长事件才能完成的，初始化消息也不会释放线程的控制权给其它消息。只要等初始化消息被全部处理完之后线程的控制权才会被释放，然后才会处理消息队列中的其它消息。<br>
　　也许没多少内容，不过这个概念很重要的。<br>
      </article>

      <article itemprop="articleBody">
　　目前的Web有两个基本方向，Ｍobile和PC。对于MobileWeb，我目前并不太看好，具体原因下面会分析。而PC上的Web还是很有发展空间的，但发展的速度可能不会太快。Web技术是一种复合技术，对其近期可能的趋势需要从多个具体的技术方面来分析。<br>
　　首先是Mobile的情况。一般而言，Web程序有这么几个优势：<br>
　　　　<strong>安全</strong>：有同源安全策略，对本地资源的访问也有限制。<br>
　　　　<strong>便捷</strong>：不用下载和安装，打开浏览器就可以用。<br>
　　　　<strong>跨平台</strong>：只需要关心浏览器兼容，和操作系统关系不大。<br>
　　那么，这些优势在Mobile上又如何呢？<br>
　　<strong>安全性方面</strong>：就操作系统本身而言，Mobile比PC已经安全了许多。至少在安装软件时可以看到软件的访问权限（至于用户会不会去看就另当别论了）。在一些系统上，软件的来源还有固定渠道，是经过官方认证的（当然也有很多不愿意付费的用户）。总之Mobile上软件本身安全性就相当高了，那么Web程序对安全性方面的贡献，在Mobile上就体现的不明显。<br>
　　<strong>便捷度方面</strong>：对于Mobile上的APP，基本都是一键安装，不像PC上那么繁琐。甚至可以把APP视为一个首次打开比较慢的Web程序，它已经非常方便了。所以Web程序对便捷度方面的贡献也同样不会太明显。<br>
　　<strong>跨平台方面</strong>：Mobile上也有一些不同的操作系统，如果做Web程序，对操作系统的兼容性问题就不会太大（但也存在）。这方面没什么好说的，Web永远是夸平台的胜利者。<br>
　　另外，目前Mobile浏览器的性能是不太乐观的，Web程序怎么也无法做出APP那样的用户体验。当然，对于一些功能需求低的网页，比如单纯的内容展示类网页，做个MobileWeb版也是不错的，这可以在被搜索到时用户更容易浏览。但对于功能类的程序而言，MobileWeb就非常不适合。<br>
　　综合这些因素考虑，我觉得目前MobileWeb上并不会用到太多高新技术。MobileWeb只适用于一些简单的项目，或者开发预算上不足以完成APP开发的项目，又或者是作为已有APP的一个宣传项目的简易实现。我觉得MobileWeb发展的瓶颈在于浏览器的性能，总之目前我对MobileWeb并不太感兴趣。<br>
　　那么PC端又如何呢？这就很难说了，传统的Web架构是根深蒂固的，也是最稳定。很多网站可能根本不会想着使用新技术，程序能正常运行就阿弥陀佛了。但趋势总是有的，从QQ空间的实时推送到贴吧的动态提醒（也许微博也有类似的东西，但我不玩微博不太了解），网页对于实时通信的需求将会越来越高。钛合金F5的时代迟早会成为历史。<br>
　　下面是一些具体的技术方面分析。<br>
　　<strong>布局方面</strong>：HTML5+CSS3的使用已经非常流行，即使低版本浏览器不能支持一些CSS3特性，大家也不会浪费大量时间去做兼容的实现了。人们已经不会再想着让全浏览器实现同样的效果，而是尽可能的让低版本浏览器正常显示，高版本浏览器显示的更好。另外，响应式的网页也许会很快普及起来，因为响应式的实现并不困难，而且目前即使是PC端，屏幕分辨率的差异也是非常大的。当然也未必会直接使用基本的响应式设计，可能会使用基于响应式的一些扩展概念来设计，这方面还有待研究。<br>
　　<strong>绘图方面</strong>：SVG技术可能会普及，虽然IE8不能支持，但接下来人们可能会对IE9之前的IE版本越来越不重视。网站本身可以兼容，但并不会去做完美兼容，可能在这些浏览器上只能使用基本功能，不会浪费时间去做新功能的低版本兼容支持。SVG在一些矢量图绘制上是非常有效的，特别是对网页中一些可交互图表的设计，SVG可能比Canvas更适用。至于WebGL，虽然IE11已经支持，但我觉得这个技术还不够成熟，目前还不适合在实际项目中适用。<br>
　　<strong>通信方面</strong>：服务器推送技术的选用可能依然还是长轮询之类的，WebSocket的普及可能没那么快，因为使用WebSocket就牵涉到了架构调整的问题，对于现有的一些旧项目，这样的调整是很困难的。新项目会用WebSocket技术的可能性也许会高一些。另外，SPDY可能会逐渐普及起来，目前电子商务类网站是比较火的，他们需要很高的通信安全和传输性能优化，所以SPDY非常符合要求。<br>
　　<strong>存储方面</strong>：LocalStorage可能会更流行，至少IE8是支持这玩意儿的。indexedDB的兼容性和性能都是个坑，是否真的可用我还在测试阶段，但就目前浏览器对其的实现来看并不乐观。其它存储方式如WebSQL之类的就可以完全不用考虑了。<br>
　　<strong>服务器程序</strong>：NodeJS/C++是个趋势，至少它在性能上就比PHP、.NET，这些老牌的服务器语言高的多（应该也比JSP高，但JSP我不了解就不扯了）。而且NodeJS对通信方面的支持非常好，这正是未来Web发展的基石。但就近期而言，这可能只会用于一些新项目中，对于已有的项目，顶多是用NodeJS扩展一些新的服务，不会直接取到原有的程序。<br>
　　<strong>数据库方面</strong>：虽然NoSQL有点儿势头，但对于数据结构复杂的大型项目而言是不适合使用的。我觉得它更适合作为一些服务器缓存机制的存储，而不是数据的主存储。而且这些新兴的数据库在CDN之类的配套服务上可能支持的还不完善。所以数据库方面的技术也许不会有太大变动。<br>
　　总结一下吧。Web技术的发展速度虽然很快，但大多数项目需要的是稳定，不会采用太新的技术。近几年Web发展的速度快是被HTML5+CSS3+ES5带出来的，但他们基本已经定格，而下一个版本在这一两年内估计是看不到了，所以近期Web的发展应该会稳定一段时间。<br>
　　最后，告诉大家一个好消息吧，国内的IE6市场份额已经跌破10%了，而Chrome马上就要突破25%了。虽然大部分还是IE8，但我想那些绝不是单纯IE8，而是一些国产双核浏览器的兼容模式，它们很多也是可以切换到现代浏览器模式的。所以应该会有更多的公司考虑放弃低版本IE的兼容。<br>
      </article>

      <article itemprop="articleBody">
　　只靠Promise就已经可以解决回调嵌套过度的问题了，Promise能把原本垂直的代码变平行。但大家还是喜欢把Generator也用上，虽然比较时髦，但我觉得即便用上Generator也不会对回调嵌套过度的问题有多少改善了，反而会让代码的逻辑变得更糟。<br>
　　其实我对ES6中Generator的设计很不满意。<var>function*(){}</var>作为一种语法，它却是函数类型的，而且它的返回结果却是一个内置对象。我觉得这些概念都是非常矛盾的。<br>
　　与普通的函数相比，Generator最了不起的地方是“函数体可以使用自身的返回值”。我这种说法有点荒诞，但以传统逻辑来看就是如此。传统函数是不可能使用自己的返回值的，因为函数一旦产生返回值就意味着函数执行结束。而Generator却可以这么写<br>
<code><a class="run" href="JavaScript:">运行</a><font color="#800080">&lt;script</font><font color="#800080">&gt;</font><br><font color="#5555AA">console.time</font>(<font color="#AA5544">"test"</font>);<br><font color="#333388">function</font>*G(){<br>&nbsp;&nbsp;setTimeout(g.next.bind(g),<font color="#CC3322">1000</font>);<br>&nbsp;&nbsp;<font color="#333388">yield</font>&nbsp;<font color="#CC3322">0</font>;<br>&nbsp;&nbsp;<font color="#5555AA">console.timeEnd</font>(<font color="#AA5544">"test"</font>);<br>};<br><font color="#333388">var</font>&nbsp;g=G();<br>g.next();<br><font color="#800080">&lt;/script&gt;</font></code>
　　先不管这么写有多蛋疼，至少这样的写法是引擎允许的吧？那么如果<var>G</var>是一个传统意义上的函数，而<var>g</var>就是这个函数被调用后的返回值，那么在<var>G</var>的函数体中使用<var>g</var>就是不合逻辑的，有一种外祖母悖论的感觉。无论上面的代码在<var>G</var>的函数体中使用<var>g</var>是直接还是间接的，或者代码这么写<br>
<code><a class="run" href="JavaScript:">运行</a><font color="#800080">&lt;script</font><font color="#800080">&gt;</font><br><font color="#5555AA">console.time</font>(<font color="#AA5544">"test"</font>);<br><font color="#333388">function</font>*G(next){<br>&nbsp;&nbsp;setTimeout(next,<font color="#CC3322">1000</font>);<br>&nbsp;&nbsp;<font color="#333388">yield</font>&nbsp;<font color="#CC3322">0</font>;<br>&nbsp;&nbsp;<font color="#5555AA">console.timeEnd</font>(<font color="#AA5544">"test"</font>);<br>};<br><font color="#333388">var</font>&nbsp;g=G(<font color="#333388">function</font>(){<br>&nbsp;&nbsp;g.next();<br>});<br>g.next();<br><font color="#800080">&lt;/script&gt;</font></code>
　　这样虽然没有直接在<var>G</var>的函数体中使用<var>g</var>，但它确实间接使用了，我觉得也同样不合适。而且，即使用<var>Promise</var>封装起来，也同样是一种间接的引用<br>
<code><a class="run" href="JavaScript:">运行</a><font color="#800080">&lt;script</font><font color="#800080">&gt;</font><br><font color="#333388">function</font>&nbsp;test(G){<br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;g=G();<br>&nbsp;&nbsp;doNext();<br>&nbsp;&nbsp;<font color="#333388">function</font>&nbsp;doNext(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;promise=g.next(e).value;<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">if</font>(promise)promise.then(<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doNext(e);<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;};<br>};<br><font color="#5555AA">console.time</font>(<font color="#AA5544">"test"</font>);<br>test(<font color="#333388">function</font>*(){<br>&nbsp;&nbsp;<font color="#333388">yield</font>&nbsp;<font color="#333388">new</font>&nbsp;Promise(<font color="#333388">function</font>(resolve){<br>&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(resolve,<font color="#CC3322">1000</font>);<br>&nbsp;&nbsp;});<br>&nbsp;&nbsp;<font color="#5555AA">console.timeEnd</font>(<font color="#AA5544">"test"</font>);<br>});<br><font color="#800080">&lt;/script&gt;</font></code>
　　虽然这样封装好之后使用并没有问题，但这和前面的代码实际上是同样的逻辑。而且有必要吗？<var>Promise</var>的话，即使没有Generator已经可以解决回调嵌套过渡的问题了<br>
<code><a class="run" href="JavaScript:">运行</a><font color="#800080">&lt;script</font><font color="#800080">&gt;</font><br><font color="#5555AA">console.time</font>(<font color="#AA5544">"test"</font>);<br><font color="#333388">new</font>&nbsp;Promise(<font color="#333388">function</font>(resolve){<br>&nbsp;&nbsp;setTimeout(resolve,<font color="#CC3322">1000</font>);<br>}).then(<font color="#333388">function</font>(){<br>&nbsp;&nbsp;<font color="#5555AA">console.timeEnd</font>(<font color="#AA5544">"test"</font>);<br>&nbsp;&nbsp;<font color="#333388">return</font>&nbsp;<font color="#333388">new</font>&nbsp;Promise(<font color="#333388">function</font>(){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//TODO</font><br>&nbsp;&nbsp;});<br>}).then(<font color="#333388">function</font>(){<br>&nbsp;&nbsp;<font color="#333388">return</font>&nbsp;<font color="#333388">new</font>&nbsp;Promise(<font color="#333388">function</font>(){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//TODO</font><br>&nbsp;&nbsp;});<br>})&nbsp;<font color="#998877">//etc.</font><br><font color="#800080">&lt;/script&gt;</font></code>
　　我觉得Generator不应该被以函数的形式定义到ES中，因为它本来就不是函数嘛！它应该是一种与代码块和函数有相似概念的新语法来定义，而且调用也不该用一个内置对象来承接后续操作。像<var>g.next(e).value</var>这样的写法，感觉就像indexedDB的API一样更像是一个库。而实际上Generator应该是一个超越传统函数的概念，我觉得应该为其添加一套运算符或语句来处理这些后续操作。<br>
　　其实我现在说这些也没啥用了，Generator这东西已经基本上没跑了，甚至很多库都已经依赖它实现了，而且Chrome马上也要开始对其默认启用了。现在这样的Generator实现方式我还是勉强能接受的，至少使用起来不会出问题。只是心中有一种“无可奈何花落去，似曾相识燕归来”的感觉。
      </article>
</body>
</html>