<!DOCTYPE html>
<html><head><meta charset="UTF-8">
<link href="/favicon.ico" rel="shortcut icon" type="image/x-icon">
<style>@import url('main.css');</style>
<script src="/jquery-1.11.1.js"></script>
<script src="/createjs.js"></script>
<title></title></head>

<body>
<div class="article s" id="article" itemscope="" itemtype="http://schema.org/Article">
      <meta itemprop="author" content="柳荣一">
      <h1 itemprop="name">WebSocket(壹) 握手连接</h1>
      <article itemprop="articleBody">
　　WebSocket虽然很先进，很好用，但却是个很麻烦的东西。与普通的Web通信机制不同，它本身可以算是一个协议。要使用WebSocket首先得让客户端和服务器建立连接，而且这个连接蛋疼的比TCP那样的传输层协议还复杂，需要通过验证KEY来做握手工作。<br>
　　这个握手协议使用的是HTTP格式的请求，并再头部分带上一个Sec-WebSocket-Key字段，服务器对这个字段加上一个特定的字符串后做一次sha1运算，然后把结果用Base64的形式以同样的方式发送回去就可以完成握手的工作了。当然，WebSocket这个协议还在不断完善更新，目前这么用是没问题的，历史版本中还出现过其它方式，这里就无视他们了。<br>
　　下面是足以完成握手的服务器端程序，使用NodeJS
<code><font color="#333388">var</font>&nbsp;crypto=require(<font color="#AA5544">'crypto'</font>);<br><font color="#333388">var</font>&nbsp;WS=<font color="#AA5544">'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</font>;<br><br>require(<font color="#AA5544">'net'</font>).createServer(<font color="#333388">function</font>(o){<br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;key;<br>&nbsp;&nbsp;o.on(<font color="#AA5544">'data'</font>,<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">if</font>(!key){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//获取发送过来的KEY</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key=e.toString().match(<font color="#33AA33">/Sec-WebSocket-Key:&nbsp;(.+)/</font>)[<font color="#CC3322">1</font>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//连接上WS这个字符串，并做一次sha1运算，最后转换成Base64</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key=crypto.createHash(<font color="#AA5544">'sha1'</font>).update(key+WS).digest(<font color="#AA5544">'base64'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//输出返回给客户端的数据，这些字段都是必须的</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'HTTP/1.1&nbsp;101&nbsp;Switching&nbsp;Protocols\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'Upgrade:&nbsp;websocket\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'Connection:&nbsp;Upgrade\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//这个字段带上服务器处理后的KEY</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'Sec-WebSocket-Accept:&nbsp;'</font>+key+<font color="#AA5544">'\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//输出空行，使HTTP头结束</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<font color="#333388">else</font>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//数据处理</font><br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;});<br>}).listen(<font color="#CC3322">8000</font>);</code>
　　客户端一段简单的代码即可
<code><font color="#333388">var</font>&nbsp;ws=<font color="#333388">new</font>&nbsp;WebSocket(<font color="#AA5544">"ws://127.0.0.1:8000"</font>);<br>ws.onerror=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;<font color="#5555AA">console.log</font>(e);<br>};<br>ws.onopen=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;<font color="#5555AA">console.log</font>(<font color="#AA5544">"握手成功"</font>);<br>};</code>
<img src="pictures/e39e48ff07b11e58760df693f49a6806.png" headerloaded="true"><br>
　　一旦握手成功就会触发open事件，否则触发error事件。在open之后就可以进行数据传输了，至于数据要如何传输这比这个握手连接要复杂的多，咱下一篇再说。<br>
      </article>
    </div>
<div class="article s" id="article" itemscope="" itemtype="http://schema.org/Article">
      <meta itemprop="author" content="柳荣一">
      <h1 itemprop="name">WebSocket(贰) 解析数据帧</h1>
      <article itemprop="articleBody">
　　知道了怎么握手只是让客户端和服务器建立连接而已，WebSocket真正麻烦的地方是在数据的传输上！为了环保，它使用了特定格式的数据帧，这个数据帧需要自己去解析（当然也有别人编写好的库可以用）。虽然官方文档描述的很详细，但是看起来还是蛋疼。<br>
　　当客户端向服务器发送一个数据时服务器收到一个数据帧，比如下面的程序
<code><font color="#998877">//客户端程序</font><br><font color="#333388">var</font>&nbsp;ws=<font color="#333388">new</font>&nbsp;WebSocket(<font color="#AA5544">"ws://127.0.0.1:8000"</font>);<br>ws.onopen=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;ws.send(<font color="#AA5544">"次碳酸钴"</font>);&nbsp;<font color="#998877">//发送数据</font><br>};</code>
<code><font color="#998877">//服务器程序</font><br><font color="#333388">var</font>&nbsp;crypto=require(<font color="#AA5544">'crypto'</font>);<br><font color="#333388">var</font>&nbsp;WS=<font color="#AA5544">'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</font>;<br><br>require(<font color="#AA5544">'net'</font>).createServer(<font color="#333388">function</font>(o){<br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;key;<br>&nbsp;&nbsp;o.on(<font color="#AA5544">'data'</font>,<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">if</font>(!key){&nbsp;<font color="#998877">//握手</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key=e.toString().match(<font color="#33AA33">/Sec-WebSocket-Key:&nbsp;(.+)/</font>)[<font color="#CC3322">1</font>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key=crypto.createHash(<font color="#AA5544">'sha1'</font>).update(key+WS).digest(<font color="#AA5544">'base64'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'HTTP/1.1&nbsp;101&nbsp;Switching&nbsp;Protocols\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'Upgrade:&nbsp;websocket\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'Connection:&nbsp;Upgrade\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'Sec-WebSocket-Accept:&nbsp;'</font>+key+<font color="#AA5544">'\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<font color="#333388">else</font>&nbsp;onmessage(e);&nbsp;<font color="#998877">//接收并交给处理函数</font><br>&nbsp;&nbsp;});<br>}).listen(<font color="#CC3322">8000</font>);<br><br><font color="#333388">function</font>&nbsp;onmessage(e){<br>&nbsp;&nbsp;<font color="#5555AA">console.log</font>(e);&nbsp;<font color="#998877">//把数据输出到控制台</font><br>};</code>
　　这里是直接把接收到的数据输出了，得到这样一个东西<br>
<img src="pictures/09fd943eb1541755ab929016ae1b59a2.png" headerloaded="true"><br>
　　这就是一个完整的数据帧，直接的16进制数据我们当然无法直接阅读，需要按照数据帧的格式把它里面的数据取出来才行。对于这个数据帧，官方文档提供了一个结构图
<code>&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3<br>&nbsp;&nbsp;0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9&nbsp;0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9&nbsp;0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9&nbsp;0&nbsp;1<br>&nbsp;+-+-+-+-+-------+-+-------------+-------------------------------+<br>&nbsp;|F|R|R|R|&nbsp;opcode|M|&nbsp;Payload&nbsp;len&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Extended&nbsp;payload&nbsp;length&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;|I|S|S|S|&nbsp;&nbsp;(4)&nbsp;&nbsp;|A|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(7)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(16/64)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;|N|V|V|V|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|S|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;(if&nbsp;payload&nbsp;len==126/127)&nbsp;&nbsp;&nbsp;|<br>&nbsp;|&nbsp;|1|2|3|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|K|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;+-+-+-+-+-------+-+-------------+&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;+<br>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended&nbsp;payload&nbsp;length&nbsp;continued,&nbsp;if&nbsp;payload&nbsp;len&nbsp;==&nbsp;127&nbsp;&nbsp;|<br>&nbsp;+&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;+-------------------------------+<br>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|Masking-key,&nbsp;if&nbsp;MASK&nbsp;set&nbsp;to&nbsp;1&nbsp;&nbsp;|<br>&nbsp;+-------------------------------+-------------------------------+<br>&nbsp;|&nbsp;Masking-key&nbsp;(continued)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Payload&nbsp;Data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;+--------------------------------&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;+<br>&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Payload&nbsp;Data&nbsp;continued&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:<br>&nbsp;+&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;-&nbsp;+<br>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Payload&nbsp;Data&nbsp;continued&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;+---------------------------------------------------------------+</code>
　　光拿出这个实在很难看懂，顶部数字用十进制而不是八进制太让人蛋疼了。当然官方文档在后面的描述中也有详细介绍，看完后再回头来看图表才能看明白。其实WebSocket目前还不太完善，很多实验性的东西，所以完全按照官方文档来理解是蛋疼的。这里就说我自己的理解。<br>
　　现在再看左上角上面的图标，左上角的四个小列，也就是4位，第一位是FIN，后面三位是RSV1到3。官方文档上说RSV是预留的空间，正常为0，这就意味着，正常情况下他们可以当做0填充，那么前4位只有第一位的FIN需要设置，FIN表示帧结束，由于这篇中它不重要就不特别介绍了。接着后面的四位是储存opcode的值，这个opcode是标识数据类型的。这样数据的第一个字节我们就能理解它的含义了，看上面16进制的数据的第一个字节81换成二进制是1000001，第一个1是FIN的值，最后一个1是opcode的值。<br>
　　接着是第二个字节的数据，它由1位的MASK和7位的PayloadLen组成，MASK标识这个数据帧的数据是否使用掩码，PayloadLen表示数据部分的长度。但是PayloadLen只有7位，换成无符号整型的话只有0到127的取值，这么小的数值当然无法描述较大的数据，因此规定当数据长度小于或等于125时候它才作为数据长度的描述，如果这个值为126，则时候后面的两个字节来储存储存数据长度，如果为127则用后面八个字节来储存数据长度。所以上面的图片第一行的最右侧那块和第二行看起来有些颓然。从我们的示例数据来看，第二个字节的8C中80是最高位为1，这意味着MASK为1，后面的C表示这个数据部分有12个字节。<br>
　　再接着是上面图表中的MaskingKey，它占四个字节，储存掩码的实体部分。但是只有在前面的MASK被设置为1时候才存在这个数据，否则不使用掩码也就没有这个数据了。看我们的示例数据，由于前面的MASK为1，所以3到6字节的“79 77 3d 41”是数据的掩码实体。<br>
　　最后是数据部分，如果掩码存在，那么所有数据都需要与掩码做一次异或运算，四个字节的掩码与所有数据字节轮流发生性关系。如果不存在掩码，那么后面的数据就可以直接使用。<br>
　　这样数据帧就解析完了。下面是我写的数据帧解析的程序，请不要吐槽代码没优化
<code><font color="#333388">function</font>&nbsp;decodeDataFrame(e){<br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;i=<font color="#CC3322">0</font>,j,s,frame={<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//解析前两个字节的基本数据</font><br>&nbsp;&nbsp;&nbsp;&nbsp;FIN:e[i]&gt;&gt;<font color="#CC3322">7</font>,Opcode:e[i++]&amp;<font color="#CC3322">15</font>,Mask:e[i]&gt;&gt;<font color="#CC3322">7</font>,<br>&nbsp;&nbsp;&nbsp;&nbsp;PayloadLength:e[i++]&amp;<font color="#CC3322">0x7F</font><br>&nbsp;&nbsp;};<br>&nbsp;&nbsp;<font color="#998877">//处理特殊长度126和127</font><br>&nbsp;&nbsp;<font color="#333388">if</font>(frame.PayloadLength==<font color="#CC3322">126</font>)<br>&nbsp;&nbsp;&nbsp;&nbsp;frame.PayloadLength=(e[i++]&lt;&lt;<font color="#CC3322">8</font>)+e[i++];<br>&nbsp;&nbsp;<font color="#333388">if</font>(frame.PayloadLength==<font color="#CC3322">127</font>)<br>&nbsp;&nbsp;&nbsp;&nbsp;i+=<font color="#CC3322">4</font>,&nbsp;<font color="#998877">//长度一般用四字节的整型，前四个字节通常为长整形留空的</font><br>&nbsp;&nbsp;&nbsp;&nbsp;frame.PayloadLength=(e[i++]&lt;&lt;<font color="#CC3322">24</font>)+(e[i++]&lt;&lt;<font color="#CC3322">16</font>)+(e[i++]&lt;&lt;<font color="#CC3322">8</font>)+e[i++];<br>&nbsp;&nbsp;<font color="#998877">//判断是否使用掩码</font><br>&nbsp;&nbsp;<font color="#333388">if</font>(frame.Mask){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//获取掩码实体</font><br>&nbsp;&nbsp;&nbsp;&nbsp;frame.MaskingKey=[e[i++],e[i++],e[i++],e[i++]];<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//对数据和掩码做异或运算</font><br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">for</font>(j=<font color="#CC3322">0</font>,s=[];j&lt;frame.PayloadLength;j++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.push(e[i+j]^frame.MaskingKey[j%<font color="#CC3322">4</font>]);<br>&nbsp;&nbsp;}<font color="#333388">else</font>&nbsp;s=e.slice(i,frame.PayloadLength);&nbsp;<font color="#998877">//否则直接使用数据</font><br>&nbsp;&nbsp;<font color="#998877">//数组转换成缓冲区来使用</font><br>&nbsp;&nbsp;s=<font color="#333388">new</font>&nbsp;Buffer(s);<br>&nbsp;&nbsp;<font color="#998877">//如果有必要则把缓冲区转换成字符串来使用</font><br>&nbsp;&nbsp;<font color="#333388">if</font>(frame.Opcode==<font color="#CC3322">1</font>)s=s.toString();<br>&nbsp;&nbsp;<font color="#998877">//设置上数据部分</font><br>&nbsp;&nbsp;frame.PayloadData=s;<br>&nbsp;&nbsp;<font color="#998877">//返回数据帧</font><br>&nbsp;&nbsp;<font color="#333388">return</font>&nbsp;frame;<br>};</code>
　　既然有了解析程序，那么我们就可以把上面实例服务器端的onmessage方法修改一下
<code><font color="#333388">function</font>&nbsp;onmessage(e){<br>&nbsp;&nbsp;e=decodeDataFrame(e);&nbsp;<font color="#998877">//解析数据帧</font><br>&nbsp;&nbsp;<font color="#5555AA">console.log</font>(e);&nbsp;<font color="#998877">//把数据帧输出到控制台</font><br>};</code>
　　<img src="pictures/49ee8ef0c18ae43e75a40f3fcea7b39f.png" headerloaded="true"><br>
　　这样服务器接收客户端穿过了的数据就没问题了。嘛，这篇文章就只说接收，至于从服务器发送到客户的情况会有更复杂的情况出现，咱下一篇再说。
      </article>
    </div>
 
<div class="article s" id="article" itemscope="" itemtype="http://schema.org/Article">
      <meta itemprop="author" content="柳荣一">
      <h1 itemprop="name">WebSocket(叁) 生成数据帧</h1>
      <article itemprop="articleBody">
　　昨天的文章中介绍了WebSocket数据帧的结构和解析。其实对从服务器发送往客户端的数据也是同样的数据帧。但因此觉得这看似和解析数据帧一样简单那就错了。我们需要自己去生成数据帧。而且会遇上和解析时候不同的问题，比如数据帧分片传输的情况。<br>
　　从服务器发送到客户端的数组帧不需要掩码，这是非常值得庆幸的地方。于是要写出一个生成数据帧的函数并不难
<code><font color="#998877">//NodeJS</font><br><font color="#333388">function</font>&nbsp;encodeDataFrame(e){<br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;s=[],o=<font color="#333388">new</font>&nbsp;Buffer(e.PayloadData),l=o.length;<br>&nbsp;&nbsp;<font color="#998877">//输入第一个字节</font><br>&nbsp;&nbsp;s.push((e.FIN&lt;&lt;<font color="#CC3322">7</font>)+e.Opcode);<br>&nbsp;&nbsp;<font color="#998877">//输入第二个字节，判断它的长度并放入相应的后续长度消息</font><br>&nbsp;&nbsp;<font color="#998877">//永远不使用掩码</font><br>&nbsp;&nbsp;<font color="#333388">if</font>(l&lt;<font color="#CC3322">126</font>)s.push(l);<br>&nbsp;&nbsp;<font color="#333388">else</font>&nbsp;<font color="#333388">if</font>(l&lt;<font color="#CC3322">0x10000</font>)s.push(<font color="#CC3322">126</font>,(l&amp;<font color="#CC3322">0xFF00</font>)&gt;&gt;<font color="#CC3322">8</font>,l&amp;<font color="#CC3322">0xFF</font>);<br>&nbsp;&nbsp;<font color="#333388">else</font>&nbsp;s.push(<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#CC3322">127</font>,&nbsp;<font color="#CC3322">0</font>,<font color="#CC3322">0</font>,<font color="#CC3322">0</font>,<font color="#CC3322">0</font>,&nbsp;<font color="#998877">//8字节数据，前4字节一般没用留空</font><br>&nbsp;&nbsp;&nbsp;&nbsp;(l&amp;<font color="#CC3322">0xFF000000</font>)&gt;&gt;<font color="#CC3322">24</font>,(l&amp;<font color="#CC3322">0xFF0000</font>)&gt;&gt;<font color="#CC3322">16</font>,(l&amp;<font color="#CC3322">0xFF00</font>)&gt;&gt;<font color="#CC3322">8</font>,l&amp;<font color="#CC3322">0xFF</font><br>&nbsp;&nbsp;);<br>&nbsp;&nbsp;<font color="#998877">//返回头部分和数据部分的合并缓冲区</font><br>&nbsp;&nbsp;<font color="#333388">return</font>&nbsp;Buffer.concat([<font color="#333388">new</font>&nbsp;Buffer(s),o]);<br>};</code>
　　可以把它用于一个实例中
<code><font color="#998877">//客户端程序</font><br><font color="#333388">var</font>&nbsp;ws=<font color="#333388">new</font>&nbsp;WebSocket(<font color="#AA5544">"ws://127.0.0.1:8000/"</font>);<br>ws.onmessage=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;<font color="#5555AA">console.log</font>(e);<br>};</code>
<code><font color="#998877">//服务器程序</font><br><font color="#333388">var</font>&nbsp;crypto=require(<font color="#AA5544">'crypto'</font>);<br><font color="#333388">var</font>&nbsp;WS=<font color="#AA5544">'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</font>;<br><br>require(<font color="#AA5544">'net'</font>).createServer(<font color="#333388">function</font>(o){<br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;key;<br>&nbsp;&nbsp;o.on(<font color="#AA5544">'data'</font>,<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">if</font>(!key){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//握手</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key=e.toString().match(<font color="#33AA33">/Sec-WebSocket-Key:&nbsp;(.+)/</font>)[<font color="#CC3322">1</font>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key=crypto.createHash(<font color="#AA5544">'sha1'</font>).update(key+WS).digest(<font color="#AA5544">'base64'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'HTTP/1.1&nbsp;101&nbsp;Switching&nbsp;Protocols\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'Upgrade:&nbsp;websocket\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'Connection:&nbsp;Upgrade\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'Sec-WebSocket-Accept:&nbsp;'</font>+key+<font color="#AA5544">'\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//握手成功后给客户端发送个数据</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(encodeDataFrame({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FIN:<font color="#CC3322">1</font>,Opcode:<font color="#CC3322">1</font>,PayloadData:<font color="#AA5544">"次碳酸钴"</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}));<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;});<br>}).listen(<font color="#CC3322">8000</font>);</code>
<img src="pictures/d4932c932335b1d15e8a3c14a7aa121b.png" headerloaded="true"><br>
　　上面是最基本的用法。但是有时候数据需要分成多个数据包来发送，这就需要用到分片，也就是使用多个数据帧来传输一个数据。分片传输分为三个部分：<br>
　　　　开始帧：FIN=0,Opcode&gt;0;一个<br>
　　　　传输帧：FIN=0,Opcode=0;零个或多个<br>
　　　　终止帧：FIN=1,Opcode=0;一个<br>
　　FIN是FINAL的缩写，它为1时表示一个数据传输结束，而开始和传输帧的时候数据都没结束，所以是0，之后最后的结束帧FIN是1。同一个数据即使分片传输，它的每个数据帧的Opcode也应该相同，为了避免冲突，只对分片传输的开始帧设置Opcode，传输帧和结束帧的Opcode留0。因此把上面实例的部分代码改成<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//握手成功后给客户端发送个数据</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(encodeDataFrame({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FIN:<font color="#CC3322">0</font>,Opcode:<font color="#CC3322">1</font>,PayloadData:<font color="#AA5544">"ABC"</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(encodeDataFrame({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FIN:<font color="#CC3322">0</font>,Opcode:<font color="#CC3322">0</font>,PayloadData:<font color="#AA5544">"-DEF-"</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(encodeDataFrame({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FIN:<font color="#CC3322">1</font>,Opcode:<font color="#CC3322">0</font>,PayloadData:<font color="#AA5544">"GHI"</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}));</code>
　　就可以在客户端得到<br>
<img src="pictures/fce403abe1d2e15a533f4b800134f0d3.png" headerloaded="true"><br>
　　这就是分片传输的关键所在。<br>
      </article>
    </div>

<div class="article s" id="article" itemscope="" itemtype="http://schema.org/Article">
      <meta itemprop="author" content="柳荣一">
      <h1 itemprop="name">WebSocket(肆) 各种操作码</h1>
      <article itemprop="articleBody">
　　前面的例子都是用了1这个操作码（Opcode）来传输文本的。没错，1这个操作码就是传输文本（UTF-8）的。还用到了在分片过程中把操作码设置为0，0也只是分片时用的。操作码是4位的，取值当然不止这两个，除了指定传输数据类型外还有其它用途的操作码。<br>
　　规范文档中也提供了一个表格
<code>&nbsp;|Opcode&nbsp;&nbsp;|&nbsp;Meaning&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Reference&nbsp;|<br>-+--------+-------------------------------------+-----------|<br>&nbsp;|&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Continuation&nbsp;Frame&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;RFC&nbsp;6455&nbsp;&nbsp;|<br>-+--------+-------------------------------------+-----------|<br>&nbsp;|&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Text&nbsp;Frame&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;RFC&nbsp;6455&nbsp;&nbsp;|<br>-+--------+-------------------------------------+-----------|<br>&nbsp;|&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Binary&nbsp;Frame&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;RFC&nbsp;6455&nbsp;&nbsp;|<br>-+--------+-------------------------------------+-----------|<br>&nbsp;|&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Connection&nbsp;Close&nbsp;Frame&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;RFC&nbsp;6455&nbsp;&nbsp;|<br>-+--------+-------------------------------------+-----------|<br>&nbsp;|&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Ping&nbsp;Frame&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;RFC&nbsp;6455&nbsp;&nbsp;|<br>-+--------+-------------------------------------+-----------|<br>&nbsp;|&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Pong&nbsp;Frame&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;RFC&nbsp;6455&nbsp;&nbsp;|<br>-+--------+-------------------------------------+-----------|</code>
　　目前就这么多个操作码被定义，其它都是预留的。0和1这两个之前的例子用过的就不说了。2这个操作码是告诉服务器不要把数据转换成字符串，直接当做二进制数据来用。这会在传输图片之类的操作中用到，至于传输图片的例子以后再给吧。这篇主要是介绍后三个操作码。<br>
　　8这个操作码是服务器向客户端请求结束当前连接用的，不要以为这很简单，WebSocket的建立连接需要握手协议，那么关闭也需要双方的协商，还有关闭的代码什么的，总之很麻烦，下回再介绍。<br>
　　9和10这两个状态码就简单些了，它们是成对的。服务器向客户端发送一个Ping帧时客户端会自动返回一个Pong帧，并且数据部分与发送的完全相同。如果不同或收不到，则说明网络有问题。下面是例子<br>
　　（encodeDataFrame与decodeDataFrame函数见<a href="article/20307.html" target="_blank">生成数据帧</a>和<a href="article/20306.html" target="_blank">解析数据帧</a>）<br>
<code><font color="#998877">//客户端程序</font><br><font color="#333388">var</font>&nbsp;ws=<font color="#333388">new</font>&nbsp;WebSocket(<font color="#AA5544">"ws://127.0.0.1:8000"</font>);</code>
<code><font color="#998877">//服务器程序</font><br><font color="#333388">var</font>&nbsp;crypto=require(<font color="#AA5544">'crypto'</font>);<br><font color="#333388">var</font>&nbsp;WS=<font color="#AA5544">'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</font>;<br>require(<font color="#AA5544">'net'</font>).createServer(<font color="#333388">function</font>(o){<br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;key;<br>&nbsp;&nbsp;o.on(<font color="#AA5544">'data'</font>,<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">if</font>(!key){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//握手</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key=e.toString().match(<font color="#33AA33">/Sec-WebSocket-Key:&nbsp;(.+)/</font>)[<font color="#CC3322">1</font>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key=crypto.createHash(<font color="#AA5544">'sha1'</font>).update(key+WS).digest(<font color="#AA5544">'base64'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'HTTP/1.1&nbsp;101&nbsp;Switching&nbsp;Protocols\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'Upgrade:&nbsp;websocket\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'Connection:&nbsp;Upgrade\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'Sec-WebSocket-Accept:&nbsp;'</font>+key+<font color="#AA5544">'\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//握手成功后给客户端发送个Ping包</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(encodeDataFrame({FIN:<font color="#CC3322">1</font>,Opcode:<font color="#CC3322">9</font>,PayloadData:<font color="#AA5544">"数据"</font>}));<br>&nbsp;&nbsp;&nbsp;&nbsp;}<font color="#333388">else</font>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//解析客户端传过来的数据帧并输出</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;data=decodeDataFrame(e);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data.PayloadData=data.PayloadData.toString();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#5555AA">console.log</font>(e);<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;});<br>}).listen(<font color="#CC3322">8000</font>);</code>
Chrome调试工具截图：<br>
<img src="pictures/0cb861b02322ae48cf54f093bfacebf8.png" headerloaded="true"><br>
NodeJS控制台截图：<br>
<img src="pictures/88784cb1f240b4158ca6e37f240bbc32.png" headerloaded="true"><br>
      </article>
    </div>

<div class="article s" id="article" itemscope="" itemtype="http://schema.org/Article">
      <meta itemprop="author" content="柳荣一">
      <h1 itemprop="name">WebSocket(伍) 断开连接</h1>
      <article itemprop="articleBody">
　　WebSocket是很民主的，啥都要协商！建立连接时需要握手协议，连断开连接都需要双方共同完成！其实断开连接直接断开TCP连接就可以了，但是这有点暴力。文明点的方法是发个请求，让对方自己断开。客户端要主动断开就必须向服务器发送8这个操作码。<br>
　　首先是服务器主导断开的情况，最简单的方法是直接把TCP连接断开，这里就不演示了。由于这对客户端来说是个意外断开，WebSocket对象采取应急措施也触发close事件。咱是文明人，当然要做点有绅士风度的事情。于是咱不从服务器断开连接，而是向客户端发送个请求断开的操作码来请求客户端自己断开。<br>
　　其实就是个操作码为8的帧。但要注意的是数据部分比较特殊。当然如果嫌麻烦可以不传，不过要是不传就和前面的霸王硬上弓一样无节操了。数据部分的前两个字节是状态码，之后的部分是关闭连接原因的文本描述，这些东西可以传到客户端。<br>
　　（encodeDataFrame与decodeDataFrame函数见<a href="article/20307.html" target="_blank">生成数据帧</a>和<a href="article/20306.html" target="_blank">解析数据帧</a>）<br>
<code><font color="#998877">//客户端程序</font><br><font color="#333388">var</font>&nbsp;ws=<font color="#333388">new</font>&nbsp;WebSocket(<font color="#AA5544">"ws://127.0.0.1:8000"</font>);<br>ws.onclose=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;<font color="#5555AA">console.log</font>(e);<br>&nbsp;&nbsp;ws.close();&nbsp;<font color="#998877">//关闭TCP连接</font><br>};</code>
<code><font color="#998877">//服务器程序</font><br><font color="#333388">var</font>&nbsp;crypto=require(<font color="#AA5544">'crypto'</font>);<br><font color="#333388">var</font>&nbsp;WS=<font color="#AA5544">'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</font>;<br>require(<font color="#AA5544">'net'</font>).createServer(<font color="#333388">function</font>(o){<br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;key;<br>&nbsp;&nbsp;o.on(<font color="#AA5544">'data'</font>,<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">if</font>(!key){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//握手</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key=e.toString().match(<font color="#33AA33">/Sec-WebSocket-Key:&nbsp;(.+)/</font>)[<font color="#CC3322">1</font>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key=crypto.createHash(<font color="#AA5544">'sha1'</font>).update(key+WS).digest(<font color="#AA5544">'base64'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'HTTP/1.1&nbsp;101&nbsp;Switching&nbsp;Protocols\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'Upgrade:&nbsp;websocket\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'Connection:&nbsp;Upgrade\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'Sec-WebSocket-Accept:&nbsp;'</font>+key+<font color="#AA5544">'\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//构造断连请求的数据部分，前面留两字节存放状态码</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;buf=<font color="#333388">new</font>&nbsp;Buffer(<font color="#AA5544">'\0\0孩子，地球太危险了，快回火星去吧！'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.writeUInt16BE(<font color="#CC3322">1000</font>,<font color="#CC3322">0</font>);&nbsp;<font color="#998877">//在头两个字节写入一个状态码</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//发送断连请求</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(encodeDataFrame({FIN:<font color="#CC3322">1</font>,Opcode:<font color="#CC3322">8</font>,PayloadData:buf}));<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;});<br>}).listen(<font color="#CC3322">8000</font>);</code>
<img src="pictures/fc3e127ea800d4897a7c56f692fb6b5f.png" headerloaded="true"><br>
　　客户端会在onclose的参数中接收到一个这样的东西，状态码和结束原因描述分别在code和reason两个参数中。规范文档中规定了很多状态码的含义，不过这个目前不是强制性的，我就不列举了。见<a href="http://tools.ietf.org/html/rfc6455#section-7.4" target="_blank" rel="nofollow">RFC6455#section-7.4</a>。客户端在收到服务器的这个断连请求后应该调用close方法来关闭，否则连接会先入停滞状态等待客户端响应。<br>
　　服务器主导断开的情况就是这样。下面是客户端主导断开的情况。客户端先要调用close方法，这个操作会发送一个断连请求到服务器上，服务器收到这个请求后把TCP连接断开即可。但是服务器程序是自己写的，这个请求也需要自己解析。<br>
<code><font color="#998877">//客户端程序</font><br><font color="#333388">var</font>&nbsp;ws=<font color="#333388">new</font>&nbsp;WebSocket(<font color="#AA5544">"ws://127.0.0.1:8000"</font>);<br>ws.onopen=<font color="#333388">function</font>(){<br>&nbsp;&nbsp;ws.close();&nbsp;<font color="#998877">//发起断连请求</font><br>};<br>ws.onclose=<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;<font color="#5555AA">console.log</font>(e);<br>};</code>
<code><font color="#333388">var</font>&nbsp;crypto=require(<font color="#AA5544">'crypto'</font>);<br><font color="#333388">var</font>&nbsp;WS=<font color="#AA5544">'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</font>;<br>require(<font color="#AA5544">'net'</font>).createServer(<font color="#333388">function</font>(o){<br>&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;key;<br>&nbsp;&nbsp;o.on(<font color="#AA5544">'data'</font>,<font color="#333388">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">if</font>(!key){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//握手</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key=e.toString().match(<font color="#33AA33">/Sec-WebSocket-Key:&nbsp;(.+)/</font>)[<font color="#CC3322">1</font>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key=crypto.createHash(<font color="#AA5544">'sha1'</font>).update(key+WS).digest(<font color="#AA5544">'base64'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'HTTP/1.1&nbsp;101&nbsp;Switching&nbsp;Protocols\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'Upgrade:&nbsp;websocket\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'Connection:&nbsp;Upgrade\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'Sec-WebSocket-Accept:&nbsp;'</font>+key+<font color="#AA5544">'\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.write(<font color="#AA5544">'\r\n'</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<font color="#333388">else</font>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">var</font>&nbsp;frame=decodeDataFrame(e);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#5555AA">console.log</font>(frame);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#333388">if</font>(frame.Opcode==<font color="#CC3322">8</font>){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//这里也可以发送个结束包来给客户端的onclose中带参数</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//var&nbsp;buf=new&nbsp;Buffer('\0\0孩子，地球太危险了，快回火星去吧！');</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//buf.writeUInt16BE(1000,0);</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#998877">//o.write(encodeDataFrame({FIN:1,Opcode:8,PayloadData:buf}));</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.end();&nbsp;<font color="#998877">//断开连接</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;});<br>}).listen(<font color="#CC3322">8000</font>);</code>
<img src="pictures/f58b0fe78529e2e47f3b8438117f26c8.png" headerloaded="true"><br>
　　总之，客户端直接调用close方法并不会关闭连接，而是发送请求到服务器请求对方。服务器接收请求后可以断开连接。这会触发客户端的close事件。当然，在断开之前也可以发送个同样的断连请求，并包含状态码和原因描述。
      </article>
    </div>

<div class="article s" id="article" itemscope="" itemtype="http://schema.org/Article">
      <meta itemprop="author" content="柳荣一">
      <h1 itemprop="name">WebSocket.swf源码</h1>
      <article itemprop="articleBody">
　　为了在低版本浏览器上兼容WebSocket不得不动用猥琐的AS来实现了。这份源码是第一个版本，基本上模拟了WebSocket在浏览器上的行为。但是由于接口不支持二进制通信，所以目前只支持文本通信。不过其它一些机制，如分片帧、关闭握手，等都实现了。<br>
　　这个程序是第一个版本，也许还存在一些不完善的地方，这将在以后的版本慢慢改进。如果有重大的更新我会重新发布新版本。另外由于AS本身没有提供sha1和base64之类的函数，我也不想引用第三方的库。所以对于WebSocket的握手协议需要的随机序列我使用固定序列，使用上并不会造成影响。只是逻辑上和标准的WebSocket规范有些出入而已。<br>
<code><font color="#0000FF">package</font>&nbsp;{<br>&nbsp;&nbsp;<font color="#808080">/*****************************************<br>&nbsp;&nbsp;&nbsp;&nbsp;WebSocket兼容方案（AS3）&nbsp;&nbsp;&nbsp;2013-08-22<br>&nbsp;&nbsp;&nbsp;&nbsp;作者：次碳酸钴（admin@web-tinker.com）<br>&nbsp;&nbsp;*****************************************/</font><br>&nbsp;&nbsp;<font color="#0000FF">import</font>&nbsp;<font color="#0000FF">flash</font><font color="#0000FF">.display</font><font color="#0000FF">.*</font>;<br>&nbsp;&nbsp;<font color="#0000FF">import</font>&nbsp;<font color="#0000FF">flash</font><font color="#0000FF">.events</font><font color="#0000FF">.*</font>;<br>&nbsp;&nbsp;<font color="#0000FF">import</font>&nbsp;<font color="#0000FF">flash</font><font color="#0000FF">.net</font><font color="#0000FF">.*</font>;<br>&nbsp;&nbsp;<font color="#0000FF">import</font>&nbsp;<font color="#0000FF">flash</font><font color="#0000FF">.utils</font><font color="#0000FF">.*</font>;<br>&nbsp;&nbsp;<font color="#0000FF">import</font>&nbsp;<font color="#0000FF">flash</font><font color="#0000FF">.system</font><font color="#0000FF">.Security</font>;<br>&nbsp;&nbsp;<font color="#0000FF">import</font>&nbsp;<font color="#0000FF">flash</font><font color="#0000FF">.external</font><font color="#0000FF">.ExternalInterface</font>;<br>&nbsp;&nbsp;<font color="#0000FF">public</font>&nbsp;<font color="#0000FF">class</font>&nbsp;WebSocket&nbsp;<font color="#0000FF">extends</font>&nbsp;<font color="#0000FF">Sprite</font>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;<font color="#0000FF">var</font><br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808080">//全局变量</font><br>&nbsp;&nbsp;&nbsp;&nbsp;socket=<font color="#0000FF">new</font>&nbsp;<font color="#0000FF">Socket</font>,<br>&nbsp;&nbsp;&nbsp;&nbsp;stream=<font color="#0000FF">new</font>&nbsp;<font color="#0000FF">ByteArray</font>,fragment,testament,<br>&nbsp;&nbsp;&nbsp;&nbsp;state=<font color="#CC3322">0</font>,<font color="#808080">//0连接,1打开,2半关闭,3关闭</font><br>&nbsp;&nbsp;&nbsp;&nbsp;id=<font color="#0000FF">stage</font><font color="#0000FF">.loaderInfo</font><font color="#0000FF">.parameters</font><font color="#0000FF">.id</font>,<br>&nbsp;&nbsp;&nbsp;&nbsp;host=<font color="#0000FF">stage</font><font color="#0000FF">.loaderInfo</font><font color="#0000FF">.parameters</font><font color="#0000FF">.host</font>,<br>&nbsp;&nbsp;&nbsp;&nbsp;port=<font color="#0000FF">stage</font><font color="#0000FF">.loaderInfo</font><font color="#0000FF">.parameters</font><font color="#0000FF">.port</font>*<font color="#CC3322">1</font>,<br>&nbsp;&nbsp;&nbsp;&nbsp;path=<font color="#0000FF">stage</font><font color="#0000FF">.loaderInfo</font><font color="#0000FF">.parameters</font><font color="#0000FF">.path</font>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808080">//全局函数</font><br>&nbsp;&nbsp;&nbsp;&nbsp;writeFrame=<font color="#0000FF">function</font>(opcode,data=null){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">var</font>&nbsp;buffer,data,mask,l,i;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">if</font>(!data)data=<font color="#0000FF">new</font>&nbsp;<font color="#0000FF">ByteArray</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer=<font color="#0000FF">new</font>&nbsp;<font color="#0000FF">ByteArray</font>,l=data<font color="#0000FF">.length</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808080">//头信息</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer<font color="#0000FF">.writeByte</font>(<font color="#CC3322">128</font>+opcode);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">if</font>(l&lt;<font color="#CC3322">126</font>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer<font color="#0000FF">.writeByte</font>(<font color="#CC3322">128</font>+l);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">else</font>&nbsp;<font color="#0000FF">if</font>(l&lt;<font color="#CC3322">0x10000</font>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer<font color="#0000FF">.writeByte</font>(<font color="#CC3322">128</font>+<font color="#CC3322">126</font>),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer<font color="#0000FF">.writeShort</font>(l);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">else</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer<font color="#0000FF">.writeByte</font>(<font color="#CC3322">128</font>+<font color="#CC3322">127</font>),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer<font color="#0000FF">.writeUnsignedInt</font>(<font color="#CC3322">0</font>),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer<font color="#0000FF">.writeUnsignedInt</font>(l);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808080">//掩码信息</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask=<font color="#0000FF">new</font>&nbsp;<font color="#0000FF">ByteArray</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask<font color="#0000FF">.writeUnsignedInt</font>(<font color="#0000FF">Math</font><font color="#0000FF">.random</font>()*<font color="#CC3322">0x100000000</font>|<font color="#CC3322">0</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer<font color="#0000FF">.writeBytes</font>(mask);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808080">//数据信息</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">for</font>(i=<font color="#CC3322">0</font>;i&lt;l;i++)buffer<font color="#0000FF">.writeByte</font>(data[i]^mask[i%<font color="#CC3322">4</font>]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808080">//发送</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket<font color="#0000FF">.writeBytes</font>(buffer);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket<font color="#0000FF">.flush</font>();<br>&nbsp;&nbsp;&nbsp;&nbsp;},readFrame=<font color="#0000FF">function</font>(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">var</font>&nbsp;fin,opcode,data,size,temp,frame;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream<font color="#0000FF">.position</font>=<font color="#CC3322">0</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808080">//读取帧的头信息</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp=stream<font color="#0000FF">.readByte</font>(),fin=(temp&amp;<font color="#CC3322">128</font>)&gt;&gt;<font color="#CC3322">7</font>,opcode=temp&amp;<font color="#CC3322">127</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size=stream<font color="#0000FF">.readByte</font>()&amp;<font color="#CC3322">127</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">if</font>(size==<font color="#CC3322">126</font>)size=stream<font color="#0000FF">.readUnsignedShort</font>();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">else</font>&nbsp;<font color="#0000FF">if</font>(size==<font color="#CC3322">127</font>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream<font color="#0000FF">.posotion</font>+=<font color="#CC3322">4</font>,size=stream<font color="#0000FF">.readUnsignedInt</font>();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">if</font>(stream<font color="#0000FF">.length</font>&lt;stream<font color="#0000FF">.position</font>+size)<font color="#0000FF">return</font>;&nbsp;<font color="#808080">//不足一帧</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808080">//读取需要的数据，并从stream中删除不需要的部分</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data=<font color="#0000FF">new</font>&nbsp;<font color="#0000FF">ByteArray</font>,temp=<font color="#0000FF">new</font>&nbsp;<font color="#0000FF">ByteArray</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream<font color="#0000FF">.readBytes</font>(data,<font color="#CC3322">0</font>,size);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data<font color="#0000FF">.position</font>=data<font color="#0000FF">.length</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream<font color="#0000FF">.readBytes</font>(temp);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream<font color="#0000FF">.clear</font>(),stream<font color="#0000FF">.writeBytes</font>(temp);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808080">//处理分片帧</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">if</font>(fin){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font>&nbsp;opcode?{data:data,opcode:opcode}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:(fragment<font color="#0000FF">.data</font><font color="#0000FF">.writeBytes</font>(data),fragment);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font color="#0000FF">else</font>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">if</font>(opcode)fragment={data:data,opcode:opcode};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">else</font>&nbsp;fragment<font color="#0000FF">.data</font><font color="#0000FF">.writeBytes</font>(data);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">if</font>(stream<font color="#0000FF">.length</font>)<font color="#0000FF">return</font>&nbsp;readFrame();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;},js=<font color="#0000FF">function</font>(..<font color="#0000FF">.s</font>){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font>&nbsp;<font color="#0000FF">ExternalInterface</font><font color="#0000FF">.call</font><font color="#0000FF">.apply</font>(<font color="#0000FF">this</font>,s);<br>&nbsp;&nbsp;&nbsp;&nbsp;},log=<font color="#0000FF">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808080">//调试用，正式使用时可以注释掉</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;js(<font color="#009900">"console.log"</font>,<font color="#009900">"WebSocket:&nbsp;"</font>+e);<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808080">//构造函数</font><br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">public</font>&nbsp;<font color="#0000FF">function</font>&nbsp;WebSocket(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log(<font color="#009900">"加载完成"</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808080">//发起TCP连接</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket<font color="#0000FF">.connect</font>(host,port);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808080">//监听事件</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket<font color="#0000FF">.addEventListener</font>(<font color="#009900">"connect"</font>,<font color="#0000FF">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log(<font color="#009900">"连接成功"</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808080">//TCP连接成功发送WebSocket握手请求</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket<font color="#0000FF">.writeUTFBytes</font>([<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#009900">"GET&nbsp;"</font>+path+<font color="#009900">"&nbsp;HTTP/1.1"</font>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#009900">"Upgrade:&nbsp;websocket"</font>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#009900">"Connection:&nbsp;Upgrade"</font>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#009900">"Sec-WebSocket-Key:&nbsp;dGhlIHNhbXBsZSBub25jZQ=="</font>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#009900">"Sec-WebSocket-Version:&nbsp;13"</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<font color="#0000FF">.join</font>(<font color="#009900">"\r\n"</font>)+<font color="#009900">"\r\n\r\n"</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket<font color="#0000FF">.addEventListener</font>(<font color="#009900">"close"</font>,<font color="#0000FF">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log(<font color="#009900">"服务器断开"</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">if</font>(state==<font color="#CC3322">3</font>)<font color="#0000FF">return</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">if</font>(state==<font color="#CC3322">2</font>)socket<font color="#0000FF">.close</font>();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;js(<font color="#009900">"state"</font>+id,++state);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;js(<font color="#009900">"close"</font>+id,testament=testament||{code:<font color="#CC3322">1006</font>,reason:<font color="#009900">""</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket<font color="#0000FF">.addEventListener</font>(<font color="#009900">"socketData"</font>,<font color="#0000FF">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808080">//读取接收到的字节并放入stream中</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">var</font>&nbsp;buf=<font color="#0000FF">new</font>&nbsp;<font color="#0000FF">ByteArray</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket<font color="#0000FF">.readBytes</font>(buf);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream<font color="#0000FF">.position</font>=stream<font color="#0000FF">.length</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream<font color="#0000FF">.writeBytes</font>(buf);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">if</font>(state==<font color="#CC3322">0</font>){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808080">//握手返回</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream<font color="#0000FF">.position</font>=<font color="#CC3322">0</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">var</font>&nbsp;i,s=stream<font color="#0000FF">.readUTFBytes</font>(stream<font color="#0000FF">.length</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream<font color="#0000FF">.position</font>=<font color="#CC3322">0</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">if</font>((i=s<font color="#0000FF">.indexOf</font>(<font color="#009900">"\r\n\r\n"</font>))==-<font color="#CC3322">1</font>)<font color="#0000FF">return</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s=stream<font color="#0000FF">.readUTFBytes</font>(i+<font color="#CC3322">4</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">var</font>&nbsp;temp=<font color="#0000FF">new</font>&nbsp;<font color="#0000FF">ByteArray</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream<font color="#0000FF">.readBytes</font>(temp);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream<font color="#0000FF">.clear</font>(),stream<font color="#0000FF">.writeBytes</font>(temp);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">if</font>(s<font color="#0000FF">.indexOf</font>(<font color="#009900">"s3pPLMBiTxaQ9kYGzzhZRbK+xOo="</font>)!=-<font color="#CC3322">1</font>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log(<font color="#009900">"握手成功"</font>),js(<font color="#009900">"state"</font>+id,state=<font color="#CC3322">1</font>),js(<font color="#009900">"open"</font>+id);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">else</font>&nbsp;js(<font color="#009900">"error"</font>+id,<font color="#009900">"握手失败"</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font color="#0000FF">else</font>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808080">//处理数据帧</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">var</font>&nbsp;frame,temp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">while</font>(frame=readFrame()){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">switch</font>(frame<font color="#0000FF">.opcode</font>){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">case</font>&nbsp;<font color="#CC3322">1</font>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log(<font color="#009900">"收到文本帧"</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808080">//某些特殊字符无法发送到浏览器，需要转码</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">var</font>&nbsp;s=frame<font color="#0000FF">.data</font><font color="#0000FF">.toString</font>();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;js(<font color="#009900">"message"</font>+id,{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data:s<font color="#0000FF">.replace</font>(<font color="#33AA33">/\W/g</font>,<font color="#0000FF">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e=e<font color="#0000FF">.charCodeAt</font>(<font color="#CC3322">0</font>)<font color="#0000FF">.toString</font>(<font color="#CC3322">16</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font>&nbsp;<font color="#009900">"\\u"</font>+(<font color="#009900">"000"</font>+e)<font color="#0000FF">.slice</font>(-<font color="#CC3322">4</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">break</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">case</font>&nbsp;<font color="#CC3322">8</font>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log(<font color="#009900">"收到结束帧"</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">var</font>&nbsp;o=frame<font color="#0000FF">.data</font>,code=<font color="#CC3322">1006</font>,reason=<font color="#009900">""</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o<font color="#0000FF">.position</font>=<font color="#CC3322">0</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">if</font>(o<font color="#0000FF">.length</font>&gt;=<font color="#CC3322">2</font>)code=o<font color="#0000FF">.readUnsignedShort</font>();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">if</font>(o<font color="#0000FF">.length</font>&gt;<font color="#CC3322">2</font>)reason=o<font color="#0000FF">.readUTFBytes</font>(o<font color="#0000FF">.length</font>-<font color="#CC3322">2</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testament={code:code,reason:reason};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">break</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">case</font>&nbsp;<font color="#CC3322">9</font>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log(<font color="#009900">"收到ping帧"</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeFrame(<font color="#CC3322">10</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log(<font color="#009900">"发送pong帧"</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">break</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log(<font color="#009900">"收到不支持的操作码："</font>+frame<font color="#0000FF">.opcode</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket<font color="#0000FF">.addEventListener</font>(<font color="#009900">"securityError"</font>,<font color="#0000FF">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;js(<font color="#009900">"error"</font>+id,{message:<font color="#009900">"SecurityError"</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808080">//添加接口方法</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">ExternalInterface</font><font color="#0000FF">.addCallback</font>(<font color="#009900">"send"</font>,<font color="#0000FF">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">if</font>(state&gt;<font color="#CC3322">1</font>)<font color="#0000FF">return</font>&nbsp;js(<font color="#009900">"error"</font>+id,{message:<font color="#009900">"连接已断开"</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">if</font>(state==<font color="#CC3322">0</font>)<font color="#0000FF">return</font>&nbsp;js(<font color="#009900">"error"</font>+id,{message:<font color="#009900">"连接未就绪"</font>});<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">var</font>&nbsp;temp=<font color="#0000FF">new</font>&nbsp;<font color="#0000FF">ByteArray</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp<font color="#0000FF">.writeUTFBytes</font>(e);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeFrame(<font color="#CC3322">1</font>,temp);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log(<font color="#009900">"发送文本帧"</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">ExternalInterface</font><font color="#0000FF">.addCallback</font>(<font color="#009900">"close"</font>,<font color="#0000FF">function</font>(e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">if</font>(state==<font color="#CC3322">3</font>)<font color="#0000FF">return</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;js(<font color="#009900">"state"</font>+id,++state);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">if</font>(testament)<font color="#0000FF">return</font>&nbsp;socket<font color="#0000FF">.close</font>();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeFrame(<font color="#CC3322">8</font>);&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log(<font color="#009900">"发送结束帧"</font>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;};<br>};</code>
      </article>
    </div>


<div class="article s" id="article" itemscope="" itemtype="http://schema.org/Article">
      <meta itemprop="author" content="柳荣一">
      <h1 itemprop="name">关于WebSocket的一些看法</h1>
      <article itemprop="articleBody">
　　虽然各大浏览器的最新版本都支持WebSocket了，但是我觉得它是个很糟糕的协议。RFC6455只告诉我们要如何使用这个协议和使用时的一些注意事项。并没有告诉我们这个协议为什么要这样制定，很多东西感觉都是多余的，但是它又不能给出明确的解释。<br>
　　<strong>WebSocket是哪个层的协议？</strong><br>
　　总感觉WebSocket有点不伦不类，它的过程基于TCP，但又是从HTTP提升而来，实现上应该归为应用层协议。但它的功能又完全是作为数据传输用的，在功能上又应该归为传输层协议。作为应用层协议，它的功能太弱了。作为传输层协议，又不如直接使用TCP来的方便。既然提出的初衷是解决Web通信的问题，为什么不直接引入个TCP层的API呢？<br>
　　<strong>不科学的握手机制</strong><br>
　　WebSocket握手机制让人非常费解，RFC6455中并没告诉我们为什么需要这么繁琐而又幼稚的握手。WebSocket只是建立在TCP上的协议，TCP连接本身已经握了三次手，你还有什么必要再握手吗？退一步说，即使真的需要个握手机制，那这个握手机制能不设计的这么幼稚吗？一个KEY加一个固定字符串做SHA1之后再BASE64，这既起不到加密的作用也起不到识别客户端的作用，我实在想不明白为什么要这么做。<br>
　　<strong>不科学的传输机制</strong><br>
　　客户端传给服务器的数据需要用4个字节的MaskCode平铺到数据部分上做异或运算，这是要防止数据明文传输吗？但是MaskCode本身就是明文传输的，用它加密数据有什么意义吗？更何况服务器端传给客户端的数据帧根本没有这个操作，如果是为了加密，只加密一端的数据算个啥？<br>
　　<strong>现实</strong><br>
　　也许是我对它的了解还不够深入吧，到现在依然觉得WebSocket协议的设计很不科学。它作为应用层协议太弱，作为传输层协议太乱。但既然各大浏览器已经实现了WebSocket的兼容，在实际项目中还是有点儿实用价值的。虽然这篇文章是喷它的，但我更希望错的是我，而不是WebSocket。
      </article>
    </div>


</body>
</html>